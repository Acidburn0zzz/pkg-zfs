commit 9a8ad7445604ce27f2db009081bac7fda37d9da6
Author: Turbo Fredriksson <turbo@bayour.com>
Date:   Sun Feb 23 00:15:28 2014 +0100

    Misc iSCSI fixes/cleanups/attempts to get 'zfs rename' to work.
    
    !! Doesn't - a 'zfs rename' works, but most often than not, the rename
    !! IOCTL hangs. Not every time and not always on the first dataset being
    !! renamed... Seems a little to random to me.

commit 3a3deae47343ce30df0259facb106db5d3be9f94
Author: Turbo Fredriksson <turbo@bayour.com>
Date:   Sat Dec 21 07:28:03 2013 +0000

    This is iSCSI sharing for ZoL (shareiscsi).
    * Supports the following iSCSI implementations (in this order of discovery):
      + IET         http://iscsitarget.sourceforge.net
      + STGT        http://stgt.berlios.de
      + SCST        http://scst.sourceforge.net
        + Requires that SCST was compiled with /sys support (the default).
      + LIO         http://linux-iscsi.org
    * Will refuse to unshares an active target (one with sessions).
    * Supports the following options to the 'shareiscsi' property:
      + name/iqn    Full iSCSI Qualified Name (IQN), including identifier.
                    This is generated by iscsi_generate_target():
                    + Uses the content of an optional /etc/iscsi_target_id file:
                      Example: iqn.YYYY-MM.tld.domain
                    + If this file doesn't exist, it uses the current year, month
                      and domain name to generate the iqn.
                    + The dataset name is appended at the end of the iqn, with
                      slashes replaced with dots.
                      => <iqn>:<dataset>
      + lun         LUN (0-16384)
                    Default: 0 (1 for STGT)
      + type        Share mode (fileio, blockio, nullio, disk, tape)
                    STGT: ssc, pt
                    Default: blockio (disk for STGT)
      + iomode      IO mode (wb, wt, ro)
                    STGT: rdwr, aio, mmap, sg, ssc
                    Default: wt (rdwr for STGT)
      + blocksize   Logical block size (512, 1024, 2048, 4096)
                    Default: Volume blocksize, 4096 if not usable.
                    NOTE: Currently not supported for STGT (doesn't seem to be
                          an option for it in tgtadm).
      + initiator   Allow only this initiator to bind to target.
                    Currently only availible for LIO, STGT and SCST.
      + authname    Global user to use in binds on targets.
      + authpass    Password for global user.
    * If not called with a 'name/iqn' value, then force setting it.
      This so that the IQN doesn't change every month (when it is
      regenerated again). It will be generated by iscsi_generate_target()
      (see above).
    
    NOTE:
    + Moved nfs.c:foreach_nfs_shareopt() to libshare.c:foreach_shareopt()
      so that it can be (re)used in smb.c and iscsi.c.
    + Split iSCSI implementation into their own separate source files
    + Use the list_{create,insert}() etc for keeping tabs of the linked lists
      instead of using a home-made version.
    + A half second delay had to be added in lib/libzfs/libzfs_mount.c:zfs_unmount()
      after the successful unshare. This to avoid 'dataset busy' when destroying
      recursivly.
    = The 'initiator', 'authname' and 'authpass' option might have some issues:
      It will make the compatibility between the different iSCSI implementations
      questionable - can't switch between them easily (it will ONLY be availible
      in ZoL). I COULD make the option be silently ignored (instead of forcibly
      rejected if not availible).
    
      But that still doesn't solve the (possible) problem between ZoL and
      OpenZFS/Illumos (setting the option, will possibly introduce problems when
      importing the pool on something else than ZoL).
    
      So some more discussion might be needed..

Index: pkg-zfs/cmd/zfs/zfs_main.c
===================================================================
--- pkg-zfs.orig/cmd/zfs/zfs_main.c	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/cmd/zfs/zfs_main.c	2016-05-10 22:53:08.627294026 +0000
@@ -3508,6 +3508,7 @@
 			    "but unable to remount filesystem\n"));
 			break;
 		case EZFS_SHARENFSFAILED:
+		case EZFS_SHAREISCSIFAILED:
 			(void) fprintf(stderr, gettext("property may be set "
 			    "but unable to reshare filesystem\n"));
 			break;
@@ -5638,7 +5639,8 @@
 	/*
 	 * Iterate over any nested datasets.
 	 */
-	if (zfs_iter_filesystems(zhp, get_one_dataset, data) != 0) {
+	if (type == ZFS_TYPE_FILESYSTEM &&
+	    zfs_iter_filesystems(zhp, get_one_dataset, data) != 0) {
 		zfs_close(zhp);
 		return (1);
 	}
@@ -5646,7 +5648,7 @@
 	/*
 	 * Skip any datasets whose type does not match.
 	 */
-	if ((type & ZFS_TYPE_FILESYSTEM) == 0) {
+	if ((type & cbp->cb_types) == 0) {
 		zfs_close(zhp);
 		return (0);
 	}
@@ -5657,9 +5659,11 @@
 }
 
 static void
-get_all_datasets(zfs_handle_t ***dslist, size_t *count, boolean_t verbose)
+get_all_datasets(uint_t types, zfs_handle_t ***dslist, size_t *count,
+    boolean_t verbose)
 {
 	get_all_cb_t cb = { 0 };
+	cb.cb_types = types;
 	cb.cb_verbose = verbose;
 	cb.cb_getone = get_one_dataset;
 
@@ -5696,178 +5700,217 @@
 	struct mnttab mnt;
 	uint64_t zoned, canmount;
 	boolean_t shared_nfs, shared_smb;
+	zfs_type_t type = zfs_get_type(zhp);
 
-	assert(zfs_get_type(zhp) & ZFS_TYPE_FILESYSTEM);
-
-	/*
-	 * Check to make sure we can mount/share this dataset.  If we
-	 * are in the global zone and the filesystem is exported to a
-	 * local zone, or if we are in a local zone and the
-	 * filesystem is not exported, then it is an error.
-	 */
-	zoned = zfs_prop_get_int(zhp, ZFS_PROP_ZONED);
-
-	if (zoned && getzoneid() == GLOBAL_ZONEID) {
-		if (!explicit)
-			return (0);
-
-		(void) fprintf(stderr, gettext("cannot %s '%s': "
-		    "dataset is exported to a local zone\n"), cmdname,
-		    zfs_get_name(zhp));
-		return (1);
-
-	} else if (!zoned && getzoneid() != GLOBAL_ZONEID) {
-		if (!explicit)
-			return (0);
+	assert(type & (ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME));
 
-		(void) fprintf(stderr, gettext("cannot %s '%s': "
-		    "permission denied\n"), cmdname,
-		    zfs_get_name(zhp));
-		return (1);
-	}
+	if (type == ZFS_TYPE_FILESYSTEM) {
+		/*
+		 * Check to make sure we can mount/share this dataset.  If we
+		 * are in the global zone and the filesystem is exported to a
+		 * local zone, or if we are in a local zone and the
+		 * filesystem is not exported, then it is an error.
+		 */
+		zoned = zfs_prop_get_int(zhp, ZFS_PROP_ZONED);
 
-	/*
-	 * Ignore any filesystems which don't apply to us. This
-	 * includes those with a legacy mountpoint, or those with
-	 * legacy share options.
-	 */
-	verify(zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT, mountpoint,
-	    sizeof (mountpoint), NULL, NULL, 0, B_FALSE) == 0);
-	verify(zfs_prop_get(zhp, ZFS_PROP_SHARENFS, shareopts,
-	    sizeof (shareopts), NULL, NULL, 0, B_FALSE) == 0);
-	verify(zfs_prop_get(zhp, ZFS_PROP_SHARESMB, smbshareopts,
-	    sizeof (smbshareopts), NULL, NULL, 0, B_FALSE) == 0);
-
-	if (op == OP_SHARE && strcmp(shareopts, "off") == 0 &&
-	    strcmp(smbshareopts, "off") == 0) {
-		if (!explicit)
-			return (0);
+		if (zoned && getzoneid() == GLOBAL_ZONEID) {
+			if (!explicit)
+				return (0);
 
-		(void) fprintf(stderr, gettext("cannot share '%s': "
-		    "legacy share\n"), zfs_get_name(zhp));
-		(void) fprintf(stderr, gettext("use share(1M) to "
-		    "share this filesystem, or set "
-		    "sharenfs property on\n"));
-		return (1);
-	}
+			(void) fprintf(stderr, gettext("cannot %s '%s': "
+			    "dataset is exported to a local zone\n"), cmdname,
+			    zfs_get_name(zhp));
+			return (1);
+		} else if (!zoned && getzoneid() != GLOBAL_ZONEID) {
+			if (!explicit)
+				return (0);
 
-	/*
-	 * We cannot share or mount legacy filesystems. If the
-	 * shareopts is non-legacy but the mountpoint is legacy, we
-	 * treat it as a legacy share.
-	 */
-	if (strcmp(mountpoint, "legacy") == 0) {
-		if (!explicit)
-			return (0);
+			(void) fprintf(stderr, gettext("cannot %s '%s': "
+			    "permission denied\n"), cmdname,
+			    zfs_get_name(zhp));
+			return (1);
+		}
 
-		(void) fprintf(stderr, gettext("cannot %s '%s': "
-		    "legacy mountpoint\n"), cmdname, zfs_get_name(zhp));
-		(void) fprintf(stderr, gettext("use %s(1M) to "
-		    "%s this filesystem\n"), cmdname, cmdname);
-		return (1);
-	}
+		/*
+		 * Ignore any filesystems which don't apply to us. This
+		 * includes those with a legacy mountpoint, or those with
+		 * legacy share options.
+		 */
+		verify(zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT, mountpoint,
+				    sizeof (mountpoint), NULL, NULL, 0,
+				    B_FALSE) == 0);
+		verify(zfs_prop_get(zhp, ZFS_PROP_SHARENFS, shareopts,
+				    sizeof (shareopts), NULL, NULL, 0,
+				    B_FALSE) == 0);
+		verify(zfs_prop_get(zhp, ZFS_PROP_SHARESMB, smbshareopts,
+				    sizeof (smbshareopts), NULL, NULL, 0,
+				    B_FALSE) == 0);
+
+		if (op == OP_SHARE &&
+		    strcmp(shareopts, "off") == 0 &&
+		    strcmp(smbshareopts, "off") == 0) {
+			if (!explicit)
+				return (0);
 
-	if (strcmp(mountpoint, "none") == 0) {
-		if (!explicit)
-			return (0);
 
-		(void) fprintf(stderr, gettext("cannot %s '%s': no "
-		    "mountpoint set\n"), cmdname, zfs_get_name(zhp));
-		return (1);
-	}
+			(void) fprintf(stderr, gettext("cannot share '%s': "
+			    "legacy share\n"), zfs_get_name(zhp));
+			(void) fprintf(stderr, gettext("use share(1M) to "
+			    "share this filesystem, or set "
+			    "sharenfs property on\n"));
+			return (1);
+		}
 
-	/*
-	 * canmount	explicit	outcome
-	 * on		no		pass through
-	 * on		yes		pass through
-	 * off		no		return 0
-	 * off		yes		display error, return 1
-	 * noauto	no		return 0
-	 * noauto	yes		pass through
-	 */
-	canmount = zfs_prop_get_int(zhp, ZFS_PROP_CANMOUNT);
-	if (canmount == ZFS_CANMOUNT_OFF) {
-		if (!explicit)
-			return (0);
+		/*
+		 * We cannot share or mount legacy filesystems. If the
+		 * shareopts is non-legacy but the mountpoint is legacy, we
+		 * treat it as a legacy share.
+		 */
+		if (strcmp(mountpoint, "legacy") == 0) {
+			if (!explicit)
+				return (0);
 
-		(void) fprintf(stderr, gettext("cannot %s '%s': "
-		    "'canmount' property is set to 'off'\n"), cmdname,
-		    zfs_get_name(zhp));
-		return (1);
-	} else if (canmount == ZFS_CANMOUNT_NOAUTO && !explicit) {
-		return (0);
-	}
+			(void) fprintf(stderr, gettext("cannot %s '%s': "
+			    "legacy mountpoint\n"), cmdname, zfs_get_name(zhp));
+			(void) fprintf(stderr, gettext("use %s(1M) to "
+			    "%s this filesystem\n"), cmdname, cmdname);
+			return (1);
+		}
 
-	/*
-	 * At this point, we have verified that the mountpoint and/or
-	 * shareopts are appropriate for auto management. If the
-	 * filesystem is already mounted or shared, return (failing
-	 * for explicit requests); otherwise mount or share the
-	 * filesystem.
-	 */
-	switch (op) {
-	case OP_SHARE:
+		if (strcmp(mountpoint, "none") == 0) {
+			if (!explicit)
+				return (0);
 
-		shared_nfs = zfs_is_shared_nfs(zhp, NULL);
-		shared_smb = zfs_is_shared_smb(zhp, NULL);
+			(void) fprintf(stderr, gettext("cannot %s '%s': no "
+			    "mountpoint set\n"), cmdname, zfs_get_name(zhp));
+			return (1);
+		}
 
-		if ((shared_nfs && shared_smb) ||
-		    ((shared_nfs && strcmp(shareopts, "on") == 0) &&
-		    (strcmp(smbshareopts, "off") == 0)) ||
-		    ((shared_smb && strcmp(smbshareopts, "on") == 0) &&
-		    (strcmp(shareopts, "off") == 0))) {
+		/*
+		 * canmount	explicit	outcome
+		 * on		no		pass through
+		 * on		yes		pass through
+		 * off		no		return 0
+		 * off		yes		display error, return 1
+		 * noauto	no		return 0
+		 * noauto	yes		pass through
+		 */
+		canmount = zfs_prop_get_int(zhp, ZFS_PROP_CANMOUNT);
+		if (canmount == ZFS_CANMOUNT_OFF) {
 			if (!explicit)
 				return (0);
 
-			(void) fprintf(stderr, gettext("cannot share "
-			    "'%s': filesystem already shared\n"),
+			(void) fprintf(stderr, gettext("cannot %s '%s': "
+			    "'canmount' property is set to 'off'\n"), cmdname,
 			    zfs_get_name(zhp));
 			return (1);
+		} else if (canmount == ZFS_CANMOUNT_NOAUTO && !explicit) {
+			return (0);
 		}
 
-		if (!zfs_is_mounted(zhp, NULL) &&
-		    zfs_mount(zhp, NULL, 0) != 0)
-			return (1);
+		/*
+		 * At this point, we have verified that the mountpoint and/or
+		 * shareopts are appropriate for auto management. If the
+		 * filesystem is already mounted or shared, return (failing
+		 * for explicit requests); otherwise mount or share the
+		 * filesystem.
+		 */
+		switch (op) {
+		case OP_SHARE:
+			shared_nfs = zfs_is_shared_nfs(zhp, NULL);
+			shared_smb = zfs_is_shared_smb(zhp, NULL);
+
+			if ((shared_nfs && shared_smb) ||
+			    ((shared_nfs && strcmp(shareopts, "on") == 0) &&
+				(strcmp(smbshareopts, "off") == 0)) ||
+			    ((shared_smb && strcmp(smbshareopts, "on") == 0) &&
+				(strcmp(shareopts, "off") == 0))) {
+				if (!explicit)
+					return (0);
 
-		if (protocol == NULL) {
-			if (zfs_shareall(zhp) != 0)
+				(void) fprintf(stderr, gettext("cannot share "
+				    "'%s': filesystem already shared\n"),
+				    zfs_get_name(zhp));
 				return (1);
-		} else if (strcmp(protocol, "nfs") == 0) {
-			if (zfs_share_nfs(zhp))
+			}
+
+			if (!zfs_is_mounted(zhp, NULL) &&
+			    zfs_mount(zhp, NULL, 0) != 0)
 				return (1);
-		} else if (strcmp(protocol, "smb") == 0) {
-			if (zfs_share_smb(zhp))
+
+			if (protocol == NULL) {
+				if (zfs_shareall(zhp) != 0)
+					return (1);
+			} else if (strcmp(protocol, "nfs") == 0) {
+				if (zfs_share_nfs(zhp))
+					return (1);
+			} else if (strcmp(protocol, "smb") == 0) {
+				if (zfs_share_smb(zhp))
+					return (1);
+			} else {
+				(void) fprintf(stderr, gettext("cannot share "
+				    "'%s': invalid share type '%s' "
+				    "specified\n"),
+				    zfs_get_name(zhp), protocol);
 				return (1);
-		} else {
-			(void) fprintf(stderr, gettext("cannot share "
-			    "'%s': invalid share type '%s' "
-			    "specified\n"),
-			    zfs_get_name(zhp), protocol);
-			return (1);
+			}
+			break;
+
+		case OP_MOUNT:
+			if (options == NULL)
+				mnt.mnt_mntopts = "";
+			else
+				mnt.mnt_mntopts = (char *)options;
+
+			if (!hasmntopt(&mnt, MNTOPT_REMOUNT) &&
+			    zfs_is_mounted(zhp, NULL)) {
+				if (!explicit)
+					return (0);
+
+				(void) fprintf(stderr, gettext("cannot mount "
+				    "'%s': filesystem already mounted\n"),
+				    zfs_get_name(zhp));
+				return (1);
+			}
+
+			if (zfs_mount(zhp, options, flags) != 0)
+				return (1);
+			break;
 		}
+	} else {
+		assert(op == OP_SHARE);
 
-		break;
+		/*
+		 * Ignore any volumes that aren't shared.
+		 */
+		verify(zfs_prop_get(zhp, ZFS_PROP_SHAREISCSI, shareopts,
+		    sizeof (shareopts), NULL, NULL, 0, B_FALSE) == 0);
 
-	case OP_MOUNT:
-		if (options == NULL)
-			mnt.mnt_mntopts = "";
-		else
-			mnt.mnt_mntopts = (char *)options;
+		if (strcmp(shareopts, "off") == 0) {
+			if (!explicit)
+				return (0);
+
+			(void) fprintf(stderr, gettext("cannot share '%s': "
+			    "'shareiscsi' property not set\n"),
+			    zfs_get_name(zhp));
+			(void) fprintf(stderr, gettext("set 'shareiscsi' "
+			    "property or use ietadm(8) to share this "
+			    "volume\n"));
+			return (1);
+		}
 
-		if (!hasmntopt(&mnt, MNTOPT_REMOUNT) &&
-		    zfs_is_mounted(zhp, NULL)) {
+		if (zfs_is_shared_iscsi(zhp, NULL)) {
 			if (!explicit)
 				return (0);
 
-			(void) fprintf(stderr, gettext("cannot mount "
-			    "'%s': filesystem already mounted\n"),
+			(void) fprintf(stderr, gettext("cannot share "
+			    "'%s': volume already shared\n"),
 			    zfs_get_name(zhp));
 			return (1);
 		}
 
-		if (zfs_mount(zhp, options, flags) != 0)
+		if (zfs_share_iscsi(zhp) != 0)
 			return (1);
-		break;
 	}
 
 	return (0);
@@ -5930,7 +5973,7 @@
 	boolean_t verbose = B_FALSE;
 	int c, ret = 0;
 	char *options = NULL;
-	int flags = 0;
+	int types = -1, flags = 0;
 
 	/* check options */
 	while ((c = getopt(argc, argv, op == OP_MOUNT ? ":avo:O" : "a"))
@@ -5979,16 +6022,24 @@
 		size_t i, count = 0;
 		char *protocol = NULL;
 
-		if (op == OP_SHARE && argc > 0) {
+		if (op == OP_MOUNT) {
+			types = ZFS_TYPE_FILESYSTEM;
+		} else if (argc > 0) {
 			if (strcmp(argv[0], "nfs") != 0 &&
 			    strcmp(argv[0], "smb") != 0) {
+				types = ZFS_TYPE_FILESYSTEM;
+			} else if (strcmp(argv[0], "iscsi") == 0) {
+				types = ZFS_TYPE_VOLUME;
+			} else {
 				(void) fprintf(stderr, gettext("share type "
-				    "must be 'nfs' or 'smb'\n"));
+				    "must be 'nfs', 'smb' or 'iscsi'\n"));
 				usage(B_FALSE);
 			}
 			protocol = argv[0];
 			argc--;
 			argv++;
+		} else {
+			types = ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME;
 		}
 
 		if (argc != 0) {
@@ -5997,7 +6048,7 @@
 		}
 
 		start_progress_timer();
-		get_all_datasets(&dslist, &count, verbose);
+		get_all_datasets(types, &dslist, &count, verbose);
 
 		if (count == 0)
 			return (0);
@@ -6046,14 +6097,17 @@
 	} else {
 		zfs_handle_t *zhp;
 
+		types = ZFS_TYPE_FILESYSTEM;
+		if (op == OP_SHARE)
+			types |= ZFS_TYPE_VOLUME;
+
 		if (argc > 1) {
 			(void) fprintf(stderr,
 			    gettext("too many arguments\n"));
 			usage(B_FALSE);
 		}
 
-		if ((zhp = zfs_open(g_zfs, argv[0],
-		    ZFS_TYPE_FILESYSTEM)) == NULL) {
+		if ((zhp = zfs_open(g_zfs, argv[0], types)) == NULL) {
 			ret = 1;
 		} else {
 			ret = share_mount_one(zhp, op, flags, NULL, B_TRUE,
@@ -6078,7 +6132,7 @@
 }
 
 /*
- * zfs share -a [nfs | smb]
+ * zfs share -a [nfs | smb | iscsi]
  * zfs share filesystem
  *
  * Share all filesystems, or share the given filesystem.
@@ -6184,18 +6238,23 @@
 	if (op == OP_SHARE) {
 		char nfs_mnt_prop[ZFS_MAXPROPLEN];
 		char smbshare_prop[ZFS_MAXPROPLEN];
+		char iscsishare_prop[ZFS_MAXPROPLEN];
 
 		verify(zfs_prop_get(zhp, ZFS_PROP_SHARENFS, nfs_mnt_prop,
 		    sizeof (nfs_mnt_prop), NULL, NULL, 0, B_FALSE) == 0);
 		verify(zfs_prop_get(zhp, ZFS_PROP_SHARESMB, smbshare_prop,
 		    sizeof (smbshare_prop), NULL, NULL, 0, B_FALSE) == 0);
+		verify(zfs_prop_get(zhp, ZFS_PROP_SHAREISCSI, iscsishare_prop,
+		    sizeof (iscsishare_prop), NULL, NULL, 0, B_FALSE) == 0);
 
 		if (strcmp(nfs_mnt_prop, "off") == 0 &&
-		    strcmp(smbshare_prop, "off") == 0) {
+		    strcmp(smbshare_prop, "off") == 0 &&
+		    strcmp(iscsishare_prop, "off") == 0) {
 			(void) fprintf(stderr, gettext("cannot unshare "
 			    "'%s': legacy share\n"), path);
-			(void) fprintf(stderr, gettext("use exportfs(8) "
-			    "or smbcontrol(1) to unshare this filesystem\n"));
+			(void) fprintf(stderr, gettext("use exportfs(8), "
+			    "smbcontrol(1) or ietadm(8) to unshare this "
+			    "filesystem\n"));
 		} else if (!zfs_is_shared(zhp)) {
 			(void) fprintf(stderr, gettext("cannot unshare '%s': "
 			    "not currently shared\n"), path);
@@ -6236,9 +6295,9 @@
 	int do_all = 0;
 	int flags = 0;
 	int ret = 0;
-	int c;
+	int types, c;
 	zfs_handle_t *zhp;
-	char nfs_mnt_prop[ZFS_MAXPROPLEN];
+	char nfsiscsi_mnt_prop[ZFS_MAXPROPLEN];
 	char sharesmb[ZFS_MAXPROPLEN];
 
 	/* check options */
@@ -6299,9 +6358,8 @@
 			return (ENOENT);
 
 		while (getmntent(mnttab_file, &entry) == 0) {
-
 			/* ignore non-ZFS entries */
-			if (strcmp(entry.mnt_fstype, MNTTYPE_ZFS) != 0)
+			if ((strcmp(entry.mnt_fstype, MNTTYPE_ZFS) != 0))
 				continue;
 
 			/* ignore snapshots */
@@ -6317,30 +6375,34 @@
 			switch (op) {
 			case OP_SHARE:
 				verify(zfs_prop_get(zhp, ZFS_PROP_SHARENFS,
-				    nfs_mnt_prop,
-				    sizeof (nfs_mnt_prop),
+				    nfsiscsi_mnt_prop,
+				    sizeof (nfsiscsi_mnt_prop),
 				    NULL, NULL, 0, B_FALSE) == 0);
-				if (strcmp(nfs_mnt_prop, "off") != 0)
+				if (strcmp(nfsiscsi_mnt_prop, "off") != 0)
 					break;
+
 				verify(zfs_prop_get(zhp, ZFS_PROP_SHARESMB,
-				    nfs_mnt_prop,
-				    sizeof (nfs_mnt_prop),
+				    nfsiscsi_mnt_prop,
+				    sizeof (nfsiscsi_mnt_prop),
 				    NULL, NULL, 0, B_FALSE) == 0);
-				if (strcmp(nfs_mnt_prop, "off") == 0)
+				if (strcmp(nfsiscsi_mnt_prop, "off") == 0)
 					continue;
 				break;
+
 			case OP_MOUNT:
 				/* Ignore legacy mounts */
 				verify(zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT,
-				    nfs_mnt_prop,
-				    sizeof (nfs_mnt_prop),
+				    nfsiscsi_mnt_prop,
+				    sizeof (nfsiscsi_mnt_prop),
 				    NULL, NULL, 0, B_FALSE) == 0);
-				if (strcmp(nfs_mnt_prop, "legacy") == 0)
+				if (strcmp(nfsiscsi_mnt_prop, "legacy") == 0)
 					continue;
+
 				/* Ignore canmount=noauto mounts */
 				if (zfs_prop_get_int(zhp, ZFS_PROP_CANMOUNT) ==
 				    ZFS_CANMOUNT_NOAUTO)
 					continue;
+
 			default:
 				break;
 			}
@@ -6394,7 +6456,45 @@
 		uu_avl_destroy(tree);
 		uu_avl_pool_destroy(pool);
 
+		if (op == OP_SHARE) {
+			size_t i, count = 0;
+			zfs_handle_t **dslist = NULL;
+
+			get_all_datasets(ZFS_TYPE_VOLUME, &dslist, &count,
+				    B_FALSE);
+
+			if (count != 0) {
+				qsort(dslist, count, sizeof (void *),
+				    libzfs_dataset_cmp);
+
+				for (i = 0; i < count; i++) {
+					verify(zfs_prop_get(dslist[i],
+					    ZFS_PROP_SHAREISCSI,
+					    nfsiscsi_mnt_prop,
+					    sizeof (nfsiscsi_mnt_prop),
+					    NULL, NULL, 0, B_FALSE) == 0);
+					if (strcmp(nfsiscsi_mnt_prop, "off")
+					    == 0)
+						continue;
+
+					if (zfs_is_shared_iscsi(dslist[i],
+								NULL)) {
+						if (zfs_unshare_iscsi(
+						    dslist[i], NULL)
+						    != 0) {
+							ret = 1;
+						}
+					}
+
+					zfs_close(dslist[i]);
+				}
+
+				free(dslist);
+			}
+		}
 	} else {
+		/* !do_all */
+
 		if (argc != 1) {
 			if (argc == 0)
 				(void) fprintf(stderr,
@@ -6415,63 +6515,93 @@
 			return (unshare_unmount_path(op, argv[0],
 			    flags, B_FALSE));
 
-		if ((zhp = zfs_open(g_zfs, argv[0],
-		    ZFS_TYPE_FILESYSTEM)) == NULL)
+		types = ZFS_TYPE_FILESYSTEM;
+		if (op == OP_SHARE)
+			types |= ZFS_TYPE_VOLUME;
+
+		if ((zhp = zfs_open(g_zfs, argv[0], types)) == NULL)
 			return (1);
 
-		verify(zfs_prop_get(zhp, op == OP_SHARE ?
-		    ZFS_PROP_SHARENFS : ZFS_PROP_MOUNTPOINT,
-		    nfs_mnt_prop, sizeof (nfs_mnt_prop), NULL,
-		    NULL, 0, B_FALSE) == 0);
+		if (zfs_get_type(zhp) == ZFS_TYPE_FILESYSTEM) {
+			verify(zfs_prop_get(zhp, op == OP_SHARE ?
+			    ZFS_PROP_SHARENFS : ZFS_PROP_MOUNTPOINT,
+			    nfsiscsi_mnt_prop,
+			    sizeof (nfsiscsi_mnt_prop), NULL,
+			    NULL, 0, B_FALSE) == 0);
 
-		switch (op) {
-		case OP_SHARE:
-			verify(zfs_prop_get(zhp, ZFS_PROP_SHARENFS,
-			    nfs_mnt_prop,
-			    sizeof (nfs_mnt_prop),
-			    NULL, NULL, 0, B_FALSE) == 0);
-			verify(zfs_prop_get(zhp, ZFS_PROP_SHARESMB,
-			    sharesmb, sizeof (sharesmb), NULL, NULL,
-			    0, B_FALSE) == 0);
+			switch (op) {
+			case OP_SHARE:
+				verify(zfs_prop_get(zhp, ZFS_PROP_SHARENFS,
+					    nfsiscsi_mnt_prop,
+					    sizeof (nfsiscsi_mnt_prop),
+				    NULL, NULL, 0, B_FALSE) == 0);
+				verify(zfs_prop_get(zhp, ZFS_PROP_SHARESMB,
+				    sharesmb, sizeof (sharesmb), NULL, NULL,
+				    0, B_FALSE) == 0);
 
-			if (strcmp(nfs_mnt_prop, "off") == 0 &&
-			    strcmp(sharesmb, "off") == 0) {
-				(void) fprintf(stderr, gettext("cannot "
-				    "unshare '%s': legacy share\n"),
-				    zfs_get_name(zhp));
-				(void) fprintf(stderr, gettext("use "
-				    "unshare(1M) to unshare this "
-				    "filesystem\n"));
-				ret = 1;
-			} else if (!zfs_is_shared(zhp)) {
-				(void) fprintf(stderr, gettext("cannot "
-				    "unshare '%s': not currently "
-				    "shared\n"), zfs_get_name(zhp));
-				ret = 1;
-			} else if (zfs_unshareall(zhp) != 0) {
-				ret = 1;
+				if (strcmp(nfsiscsi_mnt_prop, "off") == 0 &&
+				    strcmp(sharesmb, "off") == 0) {
+					(void) fprintf(stderr, gettext("cannot "
+					    "unshare '%s': legacy share\n"),
+					    zfs_get_name(zhp));
+					(void) fprintf(stderr, gettext("use "
+					    "unshare(1M) to unshare this "
+					    "filesystem\n"));
+					ret = 1;
+				} else if (!zfs_is_shared(zhp)) {
+					(void) fprintf(stderr, gettext("cannot "
+					    "unshare '%s': not currently "
+					    "shared\n"), zfs_get_name(zhp));
+					ret = 1;
+				} else if (zfs_unshareall(zhp) != 0) {
+					ret = 1;
+				}
+				break;
+
+			case OP_MOUNT:
+				if (strcmp(nfsiscsi_mnt_prop, "legacy") == 0) {
+					(void) fprintf(stderr, gettext("cannot "
+					    "unmount '%s': legacy "
+					    "mountpoint\n"), zfs_get_name(zhp));
+					(void) fprintf(stderr, gettext("use "
+					    "umount(1M) to unmount this "
+					    "filesystem\n"));
+					ret = 1;
+				} else if (!zfs_is_mounted(zhp, NULL)) {
+					(void) fprintf(stderr, gettext("cannot "
+					    "unmount '%s': not currently "
+					    "mounted\n"),
+					    zfs_get_name(zhp));
+					ret = 1;
+				} else if (zfs_unmountall(zhp, flags) != 0) {
+					ret = 1;
+				}
+				break;
 			}
-			break;
+		} else {
+			/* !do_all && ZFS_TYPE_VOLUME */
+			assert(op == OP_SHARE);
 
-		case OP_MOUNT:
-			if (strcmp(nfs_mnt_prop, "legacy") == 0) {
-				(void) fprintf(stderr, gettext("cannot "
-				    "unmount '%s': legacy "
-				    "mountpoint\n"), zfs_get_name(zhp));
-				(void) fprintf(stderr, gettext("use "
-				    "umount(1M) to unmount this "
-				    "filesystem\n"));
+			verify(zfs_prop_get(zhp, ZFS_PROP_SHAREISCSI,
+			    nfsiscsi_mnt_prop, sizeof (nfsiscsi_mnt_prop),
+			    NULL, NULL, 0, B_FALSE) == 0);
+
+			if (strcmp(nfsiscsi_mnt_prop, "off") == 0) {
+				(void) fprintf(stderr, gettext("cannot unshare "
+				    "'%s': 'shareiscsi' property not set\n"),
+				    zfs_get_name(zhp));
+				(void) fprintf(stderr, gettext("set "
+				    "'shareiscsi' property or use "
+				    "iscsitadm(1M) to share this volume\n"));
 				ret = 1;
-			} else if (!zfs_is_mounted(zhp, NULL)) {
+			} else if (!zfs_is_shared_iscsi(zhp, NULL)) {
 				(void) fprintf(stderr, gettext("cannot "
-				    "unmount '%s': not currently "
-				    "mounted\n"),
+				    "unshare '%s': not currently shared\n"),
 				    zfs_get_name(zhp));
 				ret = 1;
-			} else if (zfs_unmountall(zhp, flags) != 0) {
+			} else if (zfs_unshare_iscsi(zhp, NULL) != 0) {
 				ret = 1;
 			}
-			break;
 		}
 
 		zfs_close(zhp);
Index: pkg-zfs/include/libzfs.h
===================================================================
--- pkg-zfs.orig/include/libzfs.h	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/include/libzfs.h	2016-05-10 22:53:08.627294026 +0000
@@ -144,6 +144,8 @@
 	EZFS_DIFF,		/* general failure of zfs diff */
 	EZFS_DIFFDATA,		/* bad zfs diff data */
 	EZFS_POOLREADONLY,	/* pool is in read-only mode */
+	EZFS_UNSHAREISCSIFAILED, /* failed to unshare over iSCSI */
+	EZFS_SHAREISCSIFAILED,	/* failed to share over iSCSI */
 	EZFS_UNKNOWN
 } zfs_error_t;
 
@@ -579,6 +581,7 @@
 	zfs_handle_t	**cb_handles;
 	size_t		cb_alloc;
 	size_t		cb_used;
+	uint_t		cb_types;
 	boolean_t	cb_verbose;
 	int		(*cb_getone)(zfs_handle_t *, void *);
 } get_all_cb_t;
@@ -737,13 +740,17 @@
  */
 extern boolean_t zfs_is_shared_nfs(zfs_handle_t *, char **);
 extern boolean_t zfs_is_shared_smb(zfs_handle_t *, char **);
+extern boolean_t zfs_is_shared_iscsi(zfs_handle_t *, char **);
 extern int zfs_share_nfs(zfs_handle_t *);
 extern int zfs_share_smb(zfs_handle_t *);
+extern int zfs_share_iscsi(zfs_handle_t *);
 extern int zfs_shareall(zfs_handle_t *);
 extern int zfs_unshare_nfs(zfs_handle_t *, const char *);
 extern int zfs_unshare_smb(zfs_handle_t *, const char *);
+extern int zfs_unshare_iscsi(zfs_handle_t *, const char *);
 extern int zfs_unshareall_nfs(zfs_handle_t *);
 extern int zfs_unshareall_smb(zfs_handle_t *);
+extern int zfs_unshareall_iscsi(zfs_handle_t *);
 extern int zfs_unshareall_bypath(zfs_handle_t *, const char *);
 extern int zfs_unshareall(zfs_handle_t *);
 extern int zfs_deleg_share_nfs(libzfs_handle_t *, char *, char *, char *,
Index: pkg-zfs/include/libzfs_impl.h
===================================================================
--- pkg-zfs.orig/include/libzfs_impl.h	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/include/libzfs_impl.h	2016-05-10 22:53:08.667293524 +0000
@@ -118,7 +118,8 @@
 typedef enum {
 	PROTO_NFS = 0,
 	PROTO_SMB = 1,
-	PROTO_END = 2
+	PROTO_ISCSI = 2,
+	PROTO_END = 3
 } zfs_share_proto_t;
 
 /*
@@ -128,7 +129,8 @@
 typedef enum {
 	SHARED_NOT_SHARED = 0x0,
 	SHARED_NFS = 0x2,
-	SHARED_SMB = 0x4
+	SHARED_SMB = 0x4,
+	SHARED_ISCSI = 0x8
 } zfs_share_type_t;
 
 int zfs_error(libzfs_handle_t *, int, const char *);
Index: pkg-zfs/include/sys/fs/zfs.h
===================================================================
--- pkg-zfs.orig/include/sys/fs/zfs.h	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/include/sys/fs/zfs.h	2016-05-10 22:53:08.667293524 +0000
@@ -156,6 +156,7 @@
 	ZFS_PROP_REDUNDANT_METADATA,
 	ZFS_PROP_OVERLAY,
 	ZFS_PROP_PREV_SNAP,
+	ZFS_PROP_SHAREISCSI,
 	ZFS_NUM_PROPS
 } zfs_prop_t;
 
@@ -332,7 +333,9 @@
 	ZFS_SHARE_NFS = 0,
 	ZFS_UNSHARE_NFS = 1,
 	ZFS_SHARE_SMB = 2,
-	ZFS_UNSHARE_SMB = 3
+	ZFS_UNSHARE_SMB = 3,
+	ZFS_SHARE_ISCSI = 4,
+	ZFS_UNSHARE_ISCSI = 5
 } zfs_share_op_t;
 
 typedef enum zfs_smb_acl_op {
Index: pkg-zfs/lib/libshare/Makefile.am
===================================================================
--- pkg-zfs.orig/lib/libshare/Makefile.am	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/lib/libshare/Makefile.am	2016-05-10 22:53:08.671293473 +0000
@@ -12,7 +12,13 @@
 	nfs.c \
 	nfs.h \
 	smb.c \
-	smb.h
+	smb.h \
+	iscsi.c \
+	iscsi_iet.c \
+	iscsi_lio.c \
+	iscsi_scst.c \
+	iscsi_stgt.c \
+	iscsi.h
 
 KERNEL_C =
 
Index: pkg-zfs/lib/libshare/README_iscsi.txt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/README_iscsi.txt	2016-05-10 22:53:08.671293473 +0000
@@ -0,0 +1,124 @@
+This is iSCSI support for the IET, SCST and STGT iSCSI target implementations.
+
+     Implementation	URL					Package name(s)
+     IET		http://iscsitarget.sourceforge.net	iscsitarget + iscsitarget-dkms
+     SCST		http://scst.sourceforge.net		iscsi-scst + scst-dkms + scst-fileio-tgt + scstadmin
+     STGT		http://stgt.berlios.de			tgt
+     LIO		http://linux-iscsi.org			lio-utils + targetcli
+
+It will call ietmadm (for IET), tgtadm (for STGT) or modify files in
+/sys/kernel/scst_tgt (for SCST) or /sys/kernel/config/target (for LIO) to both
+add or remove a iSCSI target from the call to 'zfs share':
+
+  zfs create -s -V10G mypool/test
+  zfs set shareiscsi=on mypool/test
+
+There is no need to issue 'zfs share tank/test', because ZFS will
+automatically issue the corresponding share command(s) when setting
+(or modifying) the shareiscsi property.
+
+
+The driver will execute the following commands to setup a target (example!):
+
+* For IET:
+
+  /usr/sbin/ietadm --op new --tid TID --params Name=iqn.2010-09.org.zfsonlinux:mypool.test
+  /usr/sbin/ietadm --op new --tid TID --lun LUN --params Path=/dev/zvol/mypool/test,Type=fileio
+
+* For STGT:
+
+  tgtadm --lld iscsi --op new  --mode target      --tid TID -T iqn.2010-09.org.zfsonlinux:share.test
+  tgtadm --lld iscsi --op new  --mode logicalunit --tid TID --lun 1 -b /dev/zvol/mypool/test
+  tgtadm --lld iscsi --op bind --mode target      --tid TID --initiator-address ALL
+
+* For SCST:
+
+  SYSFS_SCST="/sys/kernel/scst_tgt"
+
+  echo "add_target iqn.2010-09.org.zfsonlinux:mypool.test" > $SYSFS_SCST/targets/iscsi/mgmt
+  echo "add_device DEVICE filename=/dev/zvol/mypool/test; blocksize=BLOCKSIZE" > $SYSFS_SCST/handlers/vdisk_blockio/mgmt
+  echo "add DEVICE LUN" > $SYSFS_SCST/targets/iscsi/iqn.2010-09.org.zfsonlinux:mypool.test/luns/mgmt
+  echo 1 > $SYSFS_SCST/targets/iscsi/iqn.2010-09.org.zfsonlinux:mypool.test/enabled
+
+* For LIO
+
+  SYSFS_LIO="/sys/kernel/config/target"
+
+  # TEST DATA:
+  ip=$(ifconfig | grep 'inet addr:' | grep -v '127.0.0.1' | head -n1 | sed "s@.*addr:\(.*\)  Bcast.*@\1@")
+  md5=$(date | md5sum | cut -f1 -d' ')
+
+  # SETUP Device
+  mkdir -p $SYSFS_LIO/core/iblock_TID/mypool.test
+  echo -n "/dev/zvol/mypool/test" > $SYSFS_LIO/core/iblock_TID/mypool.test/udev_path
+  echo -n "udev_path=/dev/zvol/mypool/test" > $SYSFS_LIO/core/iblock_TID/mypool.test/control
+  echo -n $md5 > $SYSFS_LIO/core/iblock_TID/mypool.test/wwn/vpd_unit_serial
+  echo 1 > $SYSFS_LIO/core/iblock_TID/mypool.test/enable
+  echo 4096 > $SYSFS_LIO/core/iblock_TID/mypool.test/attrib/block_size
+  echo 0 > $SYSFS_LIO/core/iblock_TID/mypool.test/attrib/emulate_tas
+  echo 0 > $SYSFS_LIO/core/iblock_TID/mypool.test/attrib/emulate_ua_intlck_ctrl
+
+  # SETUP IQN/Target
+  mkdir -p $SYSFS_LIO/iscsi/iqn.2010-09.org.zfsonlinux:mypool.test/tpgt_TID/np/$ip:3260
+  mkdir -p $SYSFS_LIO/iscsi/iqn.2010-09.org.zfsonlinux:mypool.test/tpgt_TID/lun/lun_LUN
+  ln -s $SYSFS_LIO/core/iblock_TID/mypool.test \
+     $SYSFS_LIO/iscsi/iqn.2010-09.org.zfsonlinux:mypool.test/tpgt_TID/lun/lun_LUN/$md5
+  echo -n 0 > $SYSFS_LIO/iscsi/discovery_auth/enforce_discovery_auth
+  echo 0 > $SYSFS_LIO/iscsi/iqn.2010-09.org.zfsonlinux:mypool.test/tpgt_TID/attrib/authentication
+  echo 1 > $SYSFS_LIO/iscsi/iqn.2010-09.org.zfsonlinux:mypool.test/tpgt_TID/enable
+
+Here the value DEVICE is generated by iscsi.c:iscsi_generate_scst_device_name()
+and is a randomized value, based on the exact time of day when
+called. This because SCST have a limit of 16 characters for the device
+name, and the chances of have duplicates is large. The BLOCKSIZE that
+is used depends on what blocksize the ZVOL was created with.
+
+The LUN value is by default 0 (1 for STGT becase LUN0 is the controller),
+but can be overridden using the 'lun' option to the 'shareiscsi' property.
+
+It (the driver) will automatically calculate the TID and IQN and use
+only the ZVOL (in this case 'share/test') in the command lines.
+
+If autogenerating the IQN is not wanted (because each reboot or unshare/share,
+if it's done in another month, will generate a new IQN), a hardcoded default
+can be set in /etc/iscsi_target_id like so:
+
+  echo iqn.2010-09.org.zfsonlinux > /etc/iscsi_target_id
+
+Then all targets will start with this value, only adding a colon
+and the ZVOL/dataset name (slashes replaced with dots):
+
+  iqn.2010-09.org.zfsonlinux:mypool.test
+
+
+In addition to executing ietadm, tgtadm or modifying files below
+/sys/kernel/scst_tgt or /sys/kernel/config/target, zfs will execute
+the following script (if it exist and is executable)
+'/sbin/zfs_share_iscsi.sh', like so:
+
+  /sbin/zfs_share_iscsi TID
+
+This is so that one can create custom commands to be done on the
+share.
+
+The only parameter to this script/executable is the TID and the
+driver will 'execute and forget'. Meaning, it will not care about
+exit code nor any output it gives.
+
+Example scripts have been provided, on for each of the iSCSI
+implementation supported:
+
+    zfs_share_iscsi.iet
+    zfs_share_iscsi.lio
+    zfs_share_iscsi.scst
+    zfs_share_iscsi.stgt
+
+Simply copy the one for your iSCSI implementation to /sbin/zfs_share/iscsi
+and then modify it to your requirenments.
+
+PS. The domainname needs to be set (in /proc/sys/kernel/domainname
+    using either 'sysctl', 'echo' or the command 'domainname') for
+    the driver to be able to work out the iqn correctly.
+
+    NOTE: This is only required if the IQN haven't been set in the
+    	  /etc/iscsi_target_id file!
Index: pkg-zfs/lib/libshare/destroy_lio.sh
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/destroy_lio.sh	2016-05-10 22:53:08.671293473 +0000
@@ -0,0 +1,29 @@
+#!/bin/sh
+
+# This is a script to simply unshare all LIO targets, without going through
+# ZFS. Mostly used for testing...
+
+SYSFS=/sys/kernel/config/target
+
+cd $SYSFS/iscsi/
+if [ -z "$*" ]; then
+    targets=`echo iqn.*`
+else
+    targets=`echo $*`
+fi
+
+for name in $targets; do
+    tid=`echo $SYSFS/core/iblock_*/$name | sed "s@.*iblock_\(.*\)/.*@\1@"`
+    lnk=`find $SYSFS/iscsi/$name/tpgt_$tid/lun/lun_*/* | egrep -v 'alua|statistics' | sed 's@.*/@@'`
+
+    echo 0 > $SYSFS/iscsi/$name/tpgt_$tid/enable
+
+    rmdir $SYSFS/iscsi/$name/tpgt_$tid/np/*
+    rm    $SYSFS/iscsi/$name/tpgt_$tid/lun/lun_*/$lnk
+    rmdir $SYSFS/iscsi/$name/tpgt_$tid/lun/lun_*
+    rmdir $SYSFS/iscsi/$name/tpgt_$tid
+    rmdir $SYSFS/iscsi/$name
+
+    rmdir $SYSFS/core/iblock_$tid/$name
+    rmdir $SYSFS/core/iblock_$tid
+done
Index: pkg-zfs/lib/libshare/destroy_scst.sh
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/destroy_scst.sh	2016-05-10 22:53:08.703293071 +0000
@@ -0,0 +1,32 @@
+#!/bin/sh
+
+# This is a script to somply unshare all SCST targets, without going through
+# ZFS. Mostly used for testing...
+
+SYSFS=/sys/kernel/scst_tgt
+
+cd $SYSFS/targets/iscsi/
+if [ -z "$*" ]; then
+    targets=`echo iqn.*`
+else
+    targets=`echo $*`
+fi
+
+for name in $targets; do
+    find $SYSFS/targets/iscsi/$name/sessions/* -type d > /dev/null 2>&1
+    if [ "$?" -eq "1" ]; then
+        [ ! -f "$SYSFS/targets/iscsi/$name/enabled" ] && continue
+
+	#scstadmin -noprompt -disable_target $name -driver iscsi
+	echo 0 > $SYSFS/targets/iscsi/$name/enabled
+
+	#scstadmin -noprompt -close_dev $dev -handler vdisk_blockio
+	dev=`/bin/ls -l $SYSFS/targets/iscsi/$name/luns/0/device | sed 's@.*/@@'`
+	echo "del_device $dev" > $SYSFS/handlers/vdisk_blockio/mgmt
+
+	#scstadmin -noprompt -rem_target $name -driver iscsi
+	echo "del_target $name" > $SYSFS/targets/iscsi/mgmt
+    else
+	echo "Can't destroy $name - have sessions"
+    fi
+done
Index: pkg-zfs/lib/libshare/iscsi.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/iscsi.c	2016-05-10 22:53:08.703293071 +0000
@@ -0,0 +1,1219 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright (c) 2011-2014 Turbo Fredriksson <turbo@bayour.com>, loosely
+ * based on nfs.c by Gunnar Beutner.
+ *
+ * This is an addition to the zfs device driver to retrieve, add and remove
+ * iSCSI targets using either the 'ietadm' or 'tgtadm' command to add, remove
+ * and modify targets.
+ *
+ * It (the driver) will automatically calculate the TID and IQN and use only
+ * the ZVOL (in this case 'tank/test') in the command lines. Unless the optional
+ * file '/etc/iscsi_target_id' exists, in which case the content of that will
+ * be used instead for the system part of the IQN.
+ */
+
+#include <time.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <strings.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <stddef.h>
+#include <libzfs.h>
+#include <libshare.h>
+#include <sys/fs/zfs.h>
+#include "libshare_impl.h"
+#include "iscsi.h"
+
+static boolean_t iscsi_available(void);
+static boolean_t iscsi_is_share_active(sa_share_impl_t);
+
+/*
+ * See lib/libshare/iscsi_{iet,lio,scst,stgt}.c
+ */
+
+extern int iscsi_retrieve_targets_iet(void);
+extern int iscsi_enable_share_one_iet(sa_share_impl_t, int);
+extern int iscsi_disable_share_one_iet(int);
+
+extern int iscsi_retrieve_targets_lio(void);
+extern int iscsi_enable_share_one_lio(sa_share_impl_t, int);
+extern int iscsi_disable_share_one_lio(int);
+
+extern int iscsi_retrieve_targets_scst(void);
+extern int iscsi_enable_share_one_scst(sa_share_impl_t, int);
+extern int iscsi_disable_share_one_scst(int);
+
+extern int iscsi_retrieve_targets_stgt(void);
+extern int iscsi_enable_share_one_stgt(sa_share_impl_t, int);
+extern int iscsi_disable_share_one_stgt(int);
+
+list_t all_iscsi_targets_list;
+sa_fstype_t *iscsi_fstype;
+
+enum {
+	ISCSI_IMPL_NONE = 0,
+	ISCSI_IMPL_IET,
+	ISCSI_IMPL_SCST,
+	ISCSI_IMPL_STGT,
+	ISCSI_IMPL_LIO
+};
+
+/*
+ * What iSCSI implementation found
+ *  0: none
+ *  1: IET found
+ *  2: SCST found
+ *  3: STGT found
+ *  4: LIO found
+ */
+static int iscsi_implementation;
+
+/*
+ * ============================================================
+ * Support functions
+ */
+
+iscsi_session_t *
+iscsi_session_list_alloc(void)
+{
+	iscsi_session_t *session;
+
+	session = (iscsi_session_t *) malloc(sizeof (iscsi_session_t));
+	if (session == NULL)
+		return (NULL);
+
+	list_link_init(&session->next);
+
+	return (session);
+}
+
+int
+iscsi_read_sysfs_value(char *path, char **value)
+{
+	int rc = SA_SYSTEM_ERR, buffer_len;
+	char buffer[255];
+	FILE *scst_sysfs_file_fp = NULL;
+
+	/* Make sure that path and value is set */
+	assert(path != NULL);
+	if (!value)
+		return (rc);
+
+	/*
+	 * TODO:
+	 * If *value is not NULL we might be dropping allocated memory, assert?
+	 */
+	*value = NULL;
+
+#if DEBUG >= 2
+	fprintf(stderr, "iscsi_read_sysfs_value: path=%s", path);
+#endif
+
+	scst_sysfs_file_fp = fopen(path, "r");
+	if (scst_sysfs_file_fp != NULL) {
+		if (fgets(buffer, sizeof (buffer), scst_sysfs_file_fp)
+		    != NULL) {
+			/* Trim trailing new-line character(s). */
+			buffer_len = strlen(buffer);
+			while (buffer_len > 0) {
+			    buffer_len--;
+			    if (buffer[buffer_len] == '\r' ||
+				buffer[buffer_len] == '\n') {
+				buffer[buffer_len] = 0;
+			    } else
+				break;
+			}
+
+			*value = strdup(buffer);
+
+#if DEBUG >= 2
+			fprintf(stderr, ", value=%s", *value);
+#endif
+
+			/* Check that strdup() was successful */
+			if (*value)
+				rc = SA_OK;
+		}
+
+		fclose(scst_sysfs_file_fp);
+	}
+
+#if DEBUG >= 2
+	fprintf(stderr, "\n");
+#endif
+	return (rc);
+}
+
+int
+iscsi_write_sysfs_value(char *path, char *value)
+{
+	int rc = SA_SYSTEM_ERR;
+	FILE *scst_sysfs_file_fp = NULL;
+
+	/* Make sure that path and value is set */
+	assert(path != NULL);
+	assert(value != NULL);
+
+#if DEBUG >= 2
+	fprintf(stderr, "iscsi_write_sysfs_value: '%s' => '%s'\n",
+		path, value);
+#endif
+
+	scst_sysfs_file_fp = fopen(path, "w");
+	if (scst_sysfs_file_fp != NULL) {
+		if (fputs(value, scst_sysfs_file_fp) != EOF)
+			rc = SA_OK;
+
+		fclose(scst_sysfs_file_fp);
+	} else
+		rc = SA_SYSTEM_ERR;
+
+	return (rc);
+}
+
+static iscsi_dirs_t *
+iscsi_dirs_list_alloc(void)
+{
+	static iscsi_dirs_t *entries;
+
+	entries = (iscsi_dirs_t *) malloc(sizeof (iscsi_dirs_t));
+	if (entries == NULL)
+		return (NULL);
+
+	list_link_init(&entries->next);
+
+	return (entries);
+}
+
+list_t *
+iscsi_look_for_stuff(char *path, const char *needle, boolean_t match_dir,
+		int check_len)
+{
+	int ret;
+	char path2[PATH_MAX], *path3;
+	DIR *dir;
+	struct dirent *directory;
+	struct stat eStat;
+	iscsi_dirs_t *entry;
+	list_t *entries = malloc(sizeof (list_t));
+
+#if DEBUG >= 2
+	fprintf(stderr, "iscsi_look_for_stuff: '%s' (needle='%s') - %s/%d\n",
+		path, needle ? needle : "", match_dir ? "Y" : "N",
+		check_len);
+#endif
+
+	/* Make sure that path is set */
+	assert(path != NULL);
+
+	list_create(entries, sizeof (iscsi_dirs_t),
+		    offsetof(iscsi_dirs_t, next));
+
+	if ((dir = opendir(path))) {
+		while ((directory = readdir(dir))) {
+			if (directory->d_name[0] == '.')
+				continue;
+
+			path3 = NULL;
+			ret = snprintf(path2, sizeof (path2),
+					"%s/%s", path, directory->d_name);
+			if (ret < 0 || ret >= sizeof (path2))
+				/* Error or not enough space in string */
+				/* TODO: Decide to continue or break */
+				continue;
+
+			if (stat(path2, &eStat) == -1)
+				goto look_out;
+
+			if (match_dir && !S_ISDIR(eStat.st_mode))
+				continue;
+
+			if (needle != NULL) {
+				if (check_len) {
+					if (strncmp(directory->d_name,
+						    needle, check_len) == 0)
+						path3 = strdup(path2);
+				} else {
+					if (strcmp(directory->d_name, needle)
+					    == 0)
+						path3 = strdup(path2);
+				}
+			} else {
+				/* Ignore for SCST */
+				if (strcmp(directory->d_name, "mgmt") == 0)
+					continue;
+
+				/* Ignore for LIO */
+				if ((strncmp(directory->d_name, "alua", 4)
+				    == 0) ||
+				    (strcmp(directory->d_name, "statistics")
+				    == 0) ||
+				    (strcmp(directory->d_name, "write_protect")
+				    == 0))
+					continue;
+
+				path3 = strdup(path2);
+			}
+
+			if (path3) {
+				entry = iscsi_dirs_list_alloc();
+				if (entry == NULL) {
+					free(path3);
+					goto look_out;
+				}
+
+				strncpy(entry->path, path3,
+					sizeof (entry->path));
+				strncpy(entry->entry, directory->d_name,
+					sizeof (entry->entry));
+				entry->stats = eStat;
+
+#if DEBUG >= 2
+				fprintf(stderr, "  %s\n",
+					entry->path);
+#endif
+				list_insert_tail(entries, entry);
+
+				free(path3);
+			}
+		}
+
+look_out:
+		closedir(dir);
+	}
+
+	return (entries);
+}
+
+/*
+ * Generate a target name using the current year and month,
+ * the domain name and the path.
+ *
+ * http://en.wikipedia.org/wiki/ISCSI#Addressing
+ *
+ * OR: Use information from /etc/iscsi_target_id:
+ *     Example: iqn.2012-11.com.bayour
+ *
+ * => iqn.yyyy-mm.tld.domain:dataset (with . instead of / and _)
+ */
+int
+iscsi_generate_target(const char *dataset, char *iqn, size_t iqn_len)
+{
+	char tsbuf[8]; /* YYYY-MM */
+	char domain[256], revname[256], name[256],
+		tmpdom[256], *p, tmp[20][256], *pos,
+		buffer[256], file_iqn[223];  /* RFC3720: Max 223 bytes */
+	time_t now;
+	struct tm *now_local;
+	int i, ret;
+	FILE *domainname_fp = NULL, *iscsi_target_name_fp = NULL;
+
+	if (dataset == NULL)
+		return (SA_SYSTEM_ERR);
+
+	/*
+	 * Make sure file_iqn buffer contain zero byte or else strlen() later
+	 * can fail.
+	 */
+	file_iqn[0] = 0;
+
+	iscsi_target_name_fp = fopen(TARGET_NAME_FILE, "r");
+	if (iscsi_target_name_fp == NULL) {
+		/* Generate a name using domain name and date etc */
+
+		/* Get current time in EPOCH */
+		now = time(NULL);
+		now_local = localtime(&now);
+		if (now_local == NULL)
+			return (SA_SYSTEM_ERR);
+
+		/* Parse EPOCH and get YYY-MM */
+		if (strftime(tsbuf, sizeof (tsbuf), "%Y-%m", now_local) == 0)
+			return (SA_SYSTEM_ERR);
+
+		/*
+		 * Make sure domain buffer contain zero byte or else strlen()
+		 * later can fail.
+		 */
+		domain[0] = 0;
+
+#ifdef HAVE_GETDOMAINNAME
+		/* Retrieve the domain */
+		if (getdomainname(domain, sizeof (domain)) < 0) {
+			/* Could not get domain via getdomainname() */
+#endif
+			if (access(DOMAINNAME_FILE, F_OK) == 0)
+				domainname_fp = fopen(DOMAINNAME_FILE, "r");
+			else if (access(DOMAINNAME_PROC, F_OK) == 0)
+				domainname_fp = fopen(DOMAINNAME_PROC, "r");
+
+			if (domainname_fp == NULL) {
+				fprintf(stderr, "ERROR: Can't open %s: %s\n",
+					DOMAINNAME_FILE, strerror(errno));
+				return (SA_SYSTEM_ERR);
+			}
+
+			if (fgets(buffer, sizeof (buffer), domainname_fp)
+			    != NULL) {
+				strncpy(domain, buffer, sizeof (domain)-1);
+				if (domain[strlen(domain)-1] == '\n')
+					domain[strlen(domain)-1] = '\0';
+			} else
+				return (SA_SYSTEM_ERR);
+
+			fclose(domainname_fp);
+#ifdef HAVE_GETDOMAINNAME
+		}
+#endif
+
+		/* Tripple check that we really have a domainname! */
+		if ((strlen(domain) == 0) || (strcmp(domain, "(none)") == 0)) {
+			fprintf(stderr, "ERROR: Can't retreive domainname!\n");
+			return (SA_SYSTEM_ERR);
+		}
+
+		/* Reverse the domainname ('bayour.com' => 'com.bayour') */
+		strncpy(tmpdom, domain, sizeof (tmpdom));
+
+		i = 0;
+		p = strtok(tmpdom, ".");
+		while (p != NULL) {
+			if (i == 20) {
+				/* Reached end of tmp[] */
+				/* XXX: print error? */
+				return (SA_SYSTEM_ERR);
+			}
+
+			strncpy(tmp[i], p, sizeof (tmp[i]));
+			p = strtok(NULL, ".");
+
+			i++;
+		}
+		i--;
+		memset(&revname[0], 0, sizeof (revname));
+		for (; i >= 0; i--) {
+			if (strlen(revname)) {
+				ret = snprintf(tmpdom, sizeof (tmpdom),
+						"%s.%s", revname, tmp[i]);
+				if (ret < 0 || ret >= sizeof (tmpdom)) {
+					/* XXX: print error? */
+					return (SA_SYSTEM_ERR);
+				}
+
+				ret = snprintf(revname, sizeof (revname), "%s",
+						tmpdom);
+				if (ret < 0 || ret >= sizeof (revname)) {
+					/* XXX: print error? */
+					return (SA_SYSTEM_ERR);
+				}
+			} else {
+				strncpy(revname, tmp[i], sizeof (revname));
+				revname [sizeof (revname)-1] = '\0';
+			}
+		}
+	} else {
+		/*
+		 * Use the content of file as the IQN
+		 *  => "iqn.2012-11.com.bayour"
+		 */
+		if (fgets(buffer, sizeof (buffer), iscsi_target_name_fp)
+		    != NULL) {
+			strncpy(file_iqn, buffer, sizeof (file_iqn)-1);
+			file_iqn[strlen(file_iqn)-1] = '\0';
+		} else
+			return (SA_SYSTEM_ERR);
+
+		fclose(iscsi_target_name_fp);
+	}
+
+	/* Take the dataset name, replace invalid chars with . */
+	strncpy(name, dataset, sizeof (name));
+	pos = name;
+	while (*pos != '\0') {
+		switch (*pos) {
+		case '/':
+		case '-':
+		case '_':
+		case ':':
+		case ' ':
+			*pos = '.';
+		default:
+			/*
+			 * Apparently there's initiator out in the
+			 * wild that can't handle mixed case targets.
+			 * Set all lower case - violates RFC3720
+			 * though..
+			 */
+			*pos = tolower(*pos);
+		}
+		++pos;
+	}
+
+	/*
+	 * Put the whole thing togheter
+	 *  => "iqn.2012-11.com.bayour:share.VirtualMachines.Astrix"
+	 */
+	if (file_iqn[0]) {
+		ret = snprintf(iqn, iqn_len, "%s:%s", file_iqn, name);
+		if (ret < 0 || ret >= iqn_len) {
+			/* XXX: print error? */
+			return (SA_SYSTEM_ERR);
+		}
+	} else {
+		ret = snprintf(iqn, iqn_len, "iqn.%s.%s:%s", tsbuf, revname,
+				name);
+		if (ret < 0 || ret >= iqn_len) {
+			/* XXX: print error? */
+			return (SA_SYSTEM_ERR);
+		}
+	}
+
+	return (SA_OK);
+}
+
+/* Parse the 'initiator=<initiator>=<ro>;<initiator>=<ro>;.... */
+list_t *
+iscsi_parse_initiator(iscsi_shareopts_t *opts)
+{
+	char *tmp, *token, *init, *access_mode = NULL;
+	iscsi_initiator_list_t *initiators;
+	list_t *initiator_list = malloc(sizeof (list_t));
+
+	/* Make sure that initiator is set */
+	assert(opts != NULL);
+
+	list_create(initiator_list, sizeof (iscsi_initiator_list_t),
+		    offsetof(iscsi_initiator_list_t, next));
+
+#if DEBUG >= 2
+	fprintf(stderr, "iscsi_parse_initiator: %s\n", opts->initiator);
+#endif
+
+	/* Get each <initiator>=<ro|rw>, which is separated by ; */
+	/* token="iqn.1993-08.org.debian:01:a59a7552c4a=ro" */
+	token = strtok(opts->initiator, ";");
+	while (token != NULL) {
+		if (strchr(token, '=')) {
+			tmp = strchr(token, '=');
+			if (tmp == NULL)
+				return (initiator_list);
+
+			init = token;
+			access_mode = tmp + 1;
+			*tmp = '\0';
+		} else {
+			init = strdup(token);
+			access_mode = "rw";
+		}
+
+		/* Setup list */
+		initiators = (iscsi_initiator_list_t *)
+			malloc(sizeof (iscsi_initiator_list_t));
+		if (initiators == NULL)
+			return (initiator_list);
+		list_link_init(&initiators->next);
+
+		strncpy(initiators->initiator, init,
+			sizeof (initiators->initiator));
+
+		initiators->read_only = B_FALSE;
+		if (access_mode != NULL) {
+			if (strcmp(access_mode, "ro") == 0)
+				initiators->read_only = B_TRUE;
+		} else if (strcmp(opts->iomode, "ro") == 0)
+			initiators->read_only = B_TRUE;
+
+#if DEBUG >= 2
+		fprintf(stderr, "  iscsi_parse_initiator: %s=%d\n",
+			initiators->initiator, initiators->read_only);
+#endif
+		list_insert_tail(initiator_list, initiators);
+
+		token = strtok(NULL, ";");
+	}
+
+	return (initiator_list);
+}
+
+/*
+ * ============================================================
+ * Core functions
+ */
+
+/*
+ * WRAPPER: Depending on iSCSI implementation, call the
+ * relevant function but only if we haven't already.
+ * TODO: That doesn't work exactly as intended. Threading?
+ */
+static int
+iscsi_retrieve_targets(void)
+{
+	/*
+	 * TODO: Don't seem to work...
+	 *	if (!list_is_empty(&all_iscsi_targets_list)) {
+	 *		// Try to limit the number of times we do this
+	 *		fprintf(stderr, "iscsi_retrieve_targets: "
+	 *		    !list_is_empty()\n");
+	 *		return (SA_OK);
+	 *	}
+	 */
+
+	/* Create the global share list  */
+	list_create(&all_iscsi_targets_list, sizeof (iscsi_target_t),
+		    offsetof(iscsi_target_t, next));
+
+	if (iscsi_implementation == ISCSI_IMPL_IET)
+		return (iscsi_retrieve_targets_iet());
+	else if (iscsi_implementation == ISCSI_IMPL_SCST)
+		return (iscsi_retrieve_targets_scst());
+	else if (iscsi_implementation == ISCSI_IMPL_STGT)
+		return (iscsi_retrieve_targets_stgt());
+	else if (iscsi_implementation == ISCSI_IMPL_LIO)
+		return (iscsi_retrieve_targets_lio());
+	else
+		return (SA_SYSTEM_ERR);
+}
+
+/*
+ * Validates share option(s).
+ */
+static int
+iscsi_get_shareopts_cb(const char *key, const char *value, void *cookie)
+{
+	char *dup_value;
+	int lun;
+	iscsi_shareopts_t *opts = (iscsi_shareopts_t *)cookie;
+
+	if (strcmp(key, "on") == 0)
+		return (SA_OK);
+
+	/*
+	 * ======
+	 * Setup aliases
+	 */
+
+	/* iqn is an alias to name */
+	if (strcmp(key, "iqn") == 0)
+		key = "name";
+
+	/* acl is an alias to initiator - only availible for LIO */
+	if (iscsi_implementation == ISCSI_IMPL_LIO &&
+		strcmp(key, "acl") == 0)
+		key = "initiator";
+
+	/*
+	 * iotype is what's used in PROC_IET_VOLUME, but Type
+	 * in ietadm and 'type' in shareiscsi option...
+	 */
+	if (strcmp(key, "iotype") == 0 ||
+	    strcmp(key, "Type") == 0)
+		key = "type";
+
+	/* STGT calls it 'bstype' */
+	if (strcmp(key, "bstype") == 0)
+		key = "iomode";
+
+	/* Just for completeness */
+	if (strcmp(key, "BlockSize") == 0)
+		key = "blocksize";
+
+	/*
+	 * ======
+	 * Verify all options
+	 */
+
+	/* Verify valid options */
+	if (strncmp(key, "name", 4) != 0 &&
+		strcmp(key, "lun") != 0 &&
+		strcmp(key, "type") != 0 &&
+		strcmp(key, "iomode") != 0 &&
+		strcmp(key, "blocksize") != 0 &&
+		strcmp(key, "initiator") != 0 &&
+		strcmp(key, "authname") != 0 &&
+		strcmp(key, "authpass") != 0) {
+			return (SA_SYNTAX_ERR);
+	}
+
+	dup_value = strdup(value);
+	if (dup_value == NULL)
+		return (SA_NO_MEMORY);
+
+	/* Get share option values */
+	if (strncmp(key, "name", 4) == 0) {
+		strncpy(opts->name, dup_value, sizeof (opts->name));
+		opts->name [sizeof (opts->name)-1] = '\0';
+	}
+
+	if (strcmp(key, "type") == 0) {
+		/* Make sure it's a valid type value */
+		if (strcmp(dup_value, "fileio") != 0 &&
+		    strcmp(dup_value, "blockio") != 0 &&
+		    strcmp(dup_value, "iblock") != 0 && /* LIO only */
+		    strcmp(dup_value, "nullio") != 0 &&
+		    strcmp(dup_value, "disk") != 0 &&
+		    strcmp(dup_value, "tape") != 0 &&
+		    strcmp(dup_value, "ssc") != 0 &&
+		    strcmp(dup_value, "pt") != 0)
+			return (SA_SYNTAX_ERR);
+
+		/*
+		 * The *Solaris options 'disk' (and future 'tape')
+		 * isn't availible in ietadm. It _seems_ that 'fileio'
+		 * is the Linux version.
+		 *
+		 * NOTE: Only for IET and LIO
+		 */
+		if ((iscsi_implementation == ISCSI_IMPL_IET ||
+			iscsi_implementation == ISCSI_IMPL_LIO) &&
+		    (strcmp(dup_value, "disk") == 0 ||
+			strcmp(dup_value, "tape") == 0))
+			strncpy(dup_value, "fileio", 7);
+
+		/*
+		 * The STGT option ssc = tape (=> fileio)
+		 */
+		if (iscsi_implementation == ISCSI_IMPL_STGT &&
+		    strcmp(dup_value, "ssc") == 0)
+			strncpy(dup_value, "fileio", 7);
+
+		/*
+		 * The blockio option = LIO iblock
+		 */
+		if (iscsi_implementation == ISCSI_IMPL_LIO) {
+			if (strcmp(dup_value, "blockio") == 0)
+				strncpy(dup_value, "iblock", 7);
+		}
+
+		strncpy(opts->type, dup_value, sizeof (opts->type));
+		opts->type [sizeof (opts->type)-1] = '\0';
+	}
+
+	if (strcmp(key, "iomode") == 0) {
+		/* Make sure it's a valid iomode */
+		if (((iscsi_implementation == ISCSI_IMPL_SCST ||
+			iscsi_implementation == ISCSI_IMPL_IET) &&
+			strcmp(dup_value, "wb") != 0 &&
+			strcmp(dup_value, "ro") != 0 &&
+			strcmp(dup_value, "wt") != 0) ||
+		    (iscsi_implementation == ISCSI_IMPL_STGT &&
+			strcmp(dup_value, "rdwr") != 0 &&
+			strcmp(dup_value, "aio") != 0 &&
+			strcmp(dup_value, "mmap") != 0 &&
+			strcmp(dup_value, "sg") != 0 &&
+			strcmp(dup_value, "ssc") != 0) ||
+		    (iscsi_implementation == ISCSI_IMPL_LIO &&
+			strcmp(dup_value, "ro") != 0 &&
+			strcmp(dup_value, "rw") != 0))
+			return (SA_SYNTAX_ERR);
+
+		if (strcmp(opts->type, "blockio") == 0 &&
+		    strcmp(dup_value, "wb") == 0)
+			/* Can't do write-back cache with blockio */
+			strncpy(dup_value, "wt", 3);
+
+		strncpy(opts->iomode, dup_value, sizeof (opts->iomode));
+		opts->iomode [sizeof (opts->iomode)-1] = '\0';
+	}
+
+	if (strcmp(key, "lun") == 0) {
+		lun = atoi(dup_value);
+		if (iscsi_implementation == ISCSI_IMPL_STGT &&
+		    lun == 0)
+			/*
+			 * LUN0 is reserved and it isn't possible
+			 * to add a device 'backing store' to it).
+			 */
+			lun = 1;
+		else if (iscsi_implementation == ISCSI_IMPL_LIO)
+			/* LIO can only handle LUN >= 255 */
+			if (lun >= 0 && lun <= 255)
+				opts->lun = lun;
+			else
+				return (SA_SYNTAX_ERR);
+		else {
+			if (lun >= 0 && lun <= 16384)
+				opts->lun = lun;
+			else
+				return (SA_SYNTAX_ERR);
+		}
+	}
+
+	if (strcmp(key, "blocksize") == 0) {
+		/* Make sure it's a valid blocksize */
+		if (strcmp(dup_value, "512")  != 0 &&
+		    strcmp(dup_value, "1024") != 0 &&
+		    strcmp(dup_value, "2048") != 0 &&
+		    strcmp(dup_value, "4096") != 0)
+			return (SA_SYNTAX_ERR);
+
+		opts->blocksize = atoi(dup_value);
+	}
+
+	if (strcmp(key, "initiator") == 0) {
+		if (iscsi_implementation == ISCSI_IMPL_LIO ||
+			iscsi_implementation == ISCSI_IMPL_SCST ||
+			iscsi_implementation == ISCSI_IMPL_STGT) {
+			strncpy(opts->initiator, dup_value,
+				sizeof (opts->initiator));
+			opts->initiator [ sizeof (opts->initiator)-1] = '\0';
+		} else
+			return (SA_SYNTAX_ERR);
+	}
+
+	if (strcmp(key, "authname") == 0) {
+		strncpy(opts->authname, dup_value, sizeof (opts->authname));
+		opts->authname [sizeof (opts->authname)-1] = '\0';
+	}
+
+	if (strcmp(key, "authpass") == 0) {
+		if (iscsi_implementation == ISCSI_IMPL_SCST) {
+			/* Require a password of >= 12 bytes */
+			if (strlen(dup_value) < 12) {
+				fprintf(stderr, "Password to short - ");
+				return (SA_SYNTAX_ERR);
+			}
+		}
+		strncpy(opts->authpass, dup_value, sizeof (opts->authpass));
+		opts->authpass [sizeof (opts->authpass)-1] = '\0';
+	}
+
+	return (SA_OK);
+}
+
+/*
+ * Takes a string containing share options (e.g. "name=Whatever,lun=3")
+ * and converts them to a NULL-terminated array of options.
+ */
+int
+iscsi_get_shareopts(sa_share_impl_t impl_share, const char *shareopts,
+		    iscsi_shareopts_t **opts)
+{
+	char iqn[223]; /* RFC3720: Max 223 bytes */
+	int rc;
+	iscsi_shareopts_t *new_opts;
+	uint64_t blocksize;
+	zfs_handle_t *zhp;
+
+	assert(opts != NULL);
+	*opts = NULL;
+
+	new_opts = (iscsi_shareopts_t *) calloc(sizeof (iscsi_shareopts_t), 1);
+	if (new_opts == NULL)
+		return (SA_NO_MEMORY);
+
+	/* Set defaults */
+	if (impl_share && impl_share->dataset) {
+		if ((rc = iscsi_generate_target(impl_share->dataset, iqn,
+						sizeof (iqn))) != 0)
+			return (rc);
+
+		strncpy(new_opts->name, iqn, strlen(new_opts->name));
+		new_opts->name [strlen(iqn)+1] = '\0';
+	}
+
+	if (impl_share && impl_share->handle &&
+	    impl_share->handle->zfs_libhandle) {
+		/* Get the volume blocksize */
+		zhp = zfs_open(impl_share->handle->zfs_libhandle,
+				impl_share->dataset, ZFS_TYPE_VOLUME);
+
+		if (zhp == NULL)
+			return (SA_SYSTEM_ERR);
+
+		blocksize = zfs_prop_get_int(zhp, ZFS_PROP_VOLBLOCKSIZE);
+
+		zfs_close(zhp);
+
+		if (blocksize == 512 || blocksize == 1024 ||
+		    blocksize == 2048 || blocksize == 4096)
+			new_opts->blocksize = blocksize;
+		else
+			new_opts->blocksize = 4096;
+	} else
+		new_opts->blocksize = 4096;
+
+	if (iscsi_implementation == ISCSI_IMPL_STGT) {
+		strncpy(new_opts->iomode, "rdwr", 5);
+		strncpy(new_opts->type, "disk", 6);
+
+		/*
+		 * LUN0 is reserved and it isn't possible
+		 * to add a device 'backing store' to it).
+		 */
+		new_opts->lun = 1;
+	} else if (iscsi_implementation == ISCSI_IMPL_LIO) {
+		strncpy(new_opts->iomode, "rw", 5);
+		strncpy(new_opts->type, "iblock", 6);
+		new_opts->lun = 0;
+	} else {
+		strncpy(new_opts->iomode, "wt", 3);
+		strncpy(new_opts->type, "blockio", 8);
+		new_opts->lun = 0;
+	}
+	new_opts->iomode [strlen(new_opts->iomode)+1] = '\0';
+	new_opts->type [strlen(new_opts->type)+1] = '\0';
+
+	if (iscsi_implementation == ISCSI_IMPL_LIO)
+		new_opts->initiator[0] = '\0';
+	else if (iscsi_implementation == ISCSI_IMPL_SCST) {
+		strncpy(new_opts->initiator, "ALL",
+		    strlen(new_opts->initiator));
+		new_opts->initiator [strlen(new_opts->initiator)+1]
+		    = '\0';
+	}
+
+	new_opts->authname[0] = '\0';
+	new_opts->authpass[0] = '\0';
+
+	*opts = new_opts;
+
+	rc = foreach_shareopt(shareopts, iscsi_get_shareopts_cb, *opts);
+	if (rc != SA_OK) {
+		free(*opts);
+		*opts = NULL;
+	}
+
+	return (rc);
+}
+
+/* WRAPPER: Depending on iSCSI implementation, call the relevant function */
+static int
+iscsi_enable_share_one(sa_share_impl_t impl_share, int tid)
+{
+	if (iscsi_implementation == ISCSI_IMPL_IET)
+		return (iscsi_enable_share_one_iet(impl_share, tid));
+	else if (iscsi_implementation == ISCSI_IMPL_SCST)
+		return (iscsi_enable_share_one_scst(impl_share, tid));
+	else if (iscsi_implementation == ISCSI_IMPL_STGT)
+		return (iscsi_enable_share_one_stgt(impl_share, tid));
+	else if (iscsi_implementation == ISCSI_IMPL_LIO)
+		return (iscsi_enable_share_one_lio(impl_share, tid));
+	else
+		return (SA_SYSTEM_ERR);
+}
+
+static int
+iscsi_enable_share(sa_share_impl_t impl_share)
+{
+	int tid = 0, prev_tid = 0;
+	char *shareopts;
+	iscsi_target_t *target;
+
+	shareopts = FSINFO(impl_share, iscsi_fstype)->shareopts;
+	if (shareopts == NULL) /* on/off */
+		return (SA_SYSTEM_ERR);
+
+	if (strcmp(shareopts, "off") == 0)
+		return (SA_OK);
+
+	for (target = list_head(&all_iscsi_targets_list);
+	    target != NULL;
+	    target = list_next(&all_iscsi_targets_list, target)) {
+		/*
+		 * Catch the fact that IET adds the target in reverse
+		 * order (lower TID at the bottom).
+		 */
+		if (target->tid > prev_tid)
+			tid = target->tid;
+
+		prev_tid = tid;
+	}
+	tid = prev_tid + 1; /* Next TID is/should be availible */
+
+	/* Magic: Enable (i.e., 'create new') share */
+	return (iscsi_enable_share_one(impl_share, tid));
+}
+
+/* WRAPPER: Depending on iSCSI implementation, call the relevant function */
+static int
+iscsi_disable_share_one(int tid)
+{
+	if (iscsi_implementation == ISCSI_IMPL_IET)
+		return (iscsi_disable_share_one_iet(tid));
+	else if (iscsi_implementation == ISCSI_IMPL_SCST)
+		return (iscsi_disable_share_one_scst(tid));
+	else if (iscsi_implementation == ISCSI_IMPL_STGT)
+		return (iscsi_disable_share_one_stgt(tid));
+	else if (iscsi_implementation == ISCSI_IMPL_LIO)
+		return (iscsi_disable_share_one_lio(tid));
+	else
+		return (SA_SYSTEM_ERR);
+}
+
+static int
+iscsi_disable_share(sa_share_impl_t impl_share)
+{
+	int ret;
+	iscsi_target_t *target;
+
+	if (!iscsi_available())
+		return (B_FALSE);
+
+	/* Does this target have active sessions? */
+	iscsi_retrieve_targets();
+	for (target = list_head(&all_iscsi_targets_list);
+	    target != NULL;
+	    target = list_next(&all_iscsi_targets_list, target)) {
+		if (strcmp(impl_share->sharepath, target->path) == 0) {
+#ifdef DEBUG
+			fprintf(stderr, "iscsi_disable_share: target=%s, "
+				"tid=%d, path=%s\n", target->name,
+				target->tid, target->path);
+#endif
+
+			if (target->session &&
+			    target->session->state) {
+				/*
+				 * XXX: This will fail twice because
+				 *      sa_disable_share is called
+				 *      twice - once with correct protocol
+				 *      (iscsi) and once with  protocol=NULL
+				 */
+				fprintf(stderr, "Can't unshare - have active"
+					" shares\n");
+				return (SA_OK);
+			}
+
+			if ((ret = iscsi_disable_share_one(target->tid))
+			    == SA_OK)
+				list_remove(&all_iscsi_targets_list, target);
+			return (ret);
+		}
+	}
+
+	return (SA_OK);
+}
+
+static boolean_t
+iscsi_is_share_active(sa_share_impl_t impl_share)
+{
+	iscsi_target_t *target;
+
+	if (!iscsi_available())
+		return (B_FALSE);
+
+	/* Does this target have active sessions? */
+	iscsi_retrieve_targets();
+	for (target = list_head(&all_iscsi_targets_list);
+	    target != NULL;
+	    target = list_next(&all_iscsi_targets_list, target)) {
+#ifdef DEBUG
+		fprintf(stderr, "iscsi_is_share_active: %s ?? %s\n",
+			target->path, impl_share->sharepath);
+#endif
+
+		if (strcmp(target->path, impl_share->sharepath) == 0) {
+#ifdef DEBUG
+			fprintf(stderr, "=> %s is active\n", target->name);
+#endif
+			return (B_TRUE);
+		}
+	}
+
+	return (B_FALSE);
+}
+
+static int
+iscsi_validate_shareopts(const char *shareopts)
+{
+	iscsi_shareopts_t *opts;
+	int rc = SA_OK;
+
+	rc = iscsi_get_shareopts(NULL, shareopts, &opts);
+
+	free(opts);
+	return (rc);
+}
+
+static int
+iscsi_update_shareopts(sa_share_impl_t impl_share, const char *resource,
+    const char *shareopts)
+{
+	int ret;
+	char iqn[223]; /* RFC3720: Max 223 bytes */
+	char *shareopts_dup, *old_shareopts, tmp_opts[255];
+	boolean_t needs_reshare = B_FALSE, have_active_sessions = B_FALSE;
+	iscsi_target_t *target;
+	iscsi_shareopts_t *opts;
+
+	if (impl_share->dataset == NULL)
+		return (B_FALSE);
+
+	for (target = list_head(&all_iscsi_targets_list);
+	    target != NULL;
+	    target = list_next(&all_iscsi_targets_list, target)) {
+		if ((strcmp(impl_share->sharepath, target->path) == 0) &&
+		    target->session && target->session->state) {
+			have_active_sessions = B_TRUE;
+
+			break;
+		}
+	}
+
+	/* Is the share active (i.e., shared */
+	FSINFO(impl_share, iscsi_fstype)->active =
+		iscsi_is_share_active(impl_share);
+
+	/* Get old share opts */
+	old_shareopts = FSINFO(impl_share, iscsi_fstype)->shareopts;
+
+	if (strcmp(shareopts, "on") == 0 ||
+	    (strncmp(shareopts, "name=", 5) != 0 &&
+	    strncmp(shareopts, "iqn=",  4) != 0)) {
+		/*
+		 * Force a IQN value. This so that the iqn doesn't change
+		 * 'next month' (when it's regenerated again) .
+		 * NOTE: Does not change shareiscsi option, only sharetab!
+		 */
+		opts = (iscsi_shareopts_t *) malloc(sizeof (iscsi_shareopts_t));
+		if (opts == NULL)
+			return (SA_NO_MEMORY);
+
+		ret = iscsi_get_shareopts(impl_share, old_shareopts, &opts);
+		if (ret < 0) {
+			free(opts);
+			return (SA_SYSTEM_ERR);
+		}
+
+		if (opts->name != NULL) {
+			if (iscsi_generate_target(impl_share->dataset, iqn,
+					    sizeof (iqn)) == SA_OK) {
+				ret = snprintf(tmp_opts, sizeof (tmp_opts),
+					    "name=%s,%s", iqn, shareopts);
+				if (ret < 0 || ret >= sizeof (tmp_opts))
+					return (SA_SYSTEM_ERR);
+			}
+		} else {
+			ret = snprintf(tmp_opts, sizeof (tmp_opts),
+				    "name=%s,%s", opts->name, shareopts);
+			if (ret < 0 || ret >= sizeof (tmp_opts))
+				return (SA_SYSTEM_ERR);
+		}
+
+		shareopts = tmp_opts;
+	}
+
+#ifdef DEBUG
+	fprintf(stderr, "iscsi_update_shareopts: share=%s;%s,"
+		" active=%d, have_active_sessions=%d, new_shareopts=%s, "
+		"old_shareopts=%s\n",
+		impl_share->dataset, impl_share->sharepath,
+		FSINFO(impl_share, iscsi_fstype)->active, have_active_sessions,
+		shareopts,
+		FSINFO(impl_share, iscsi_fstype)->shareopts ?
+		FSINFO(impl_share, iscsi_fstype)->shareopts : "null");
+#endif
+
+	/*
+	 * RESHARE if:
+	 *  is active
+	 *  have old shareopts
+	 *  old shareopts != shareopts
+	 *  no active sessions
+	 */
+	if (FSINFO(impl_share, iscsi_fstype)->active && old_shareopts != NULL &&
+	    strcmp(old_shareopts, shareopts) != 0 && !have_active_sessions) {
+		needs_reshare = B_TRUE;
+		iscsi_disable_share(impl_share);
+	}
+
+	shareopts_dup = strdup(shareopts);
+
+	if (shareopts_dup == NULL)
+		return (SA_NO_MEMORY);
+
+	if (old_shareopts != NULL)
+		free(old_shareopts);
+
+	FSINFO(impl_share, iscsi_fstype)->shareopts = shareopts_dup;
+
+	if (needs_reshare)
+		iscsi_enable_share(impl_share);
+
+	return (SA_OK);
+}
+
+static void
+iscsi_clear_shareopts(sa_share_impl_t impl_share)
+{
+	free(FSINFO(impl_share, iscsi_fstype)->shareopts);
+	FSINFO(impl_share, iscsi_fstype)->shareopts = NULL;
+}
+
+static const sa_share_ops_t iscsi_shareops = {
+	.enable_share = iscsi_enable_share,
+	.disable_share = iscsi_disable_share,
+
+	.validate_shareopts = iscsi_validate_shareopts,
+	.update_shareopts = iscsi_update_shareopts,
+	.clear_shareopts = iscsi_clear_shareopts,
+};
+
+/*
+ * Provides a convenient wrapper for determing iscsi availability
+ */
+static boolean_t
+iscsi_available(void)
+{
+	struct stat eStat;
+
+	iscsi_implementation = ISCSI_IMPL_NONE;
+
+	if (access(PROC_IET_VOLUME, F_OK) == 0 &&
+	    access(IETM_CMD_PATH, X_OK) == 0) {
+		iscsi_implementation = ISCSI_IMPL_IET;
+#ifdef DEBUG
+		fprintf(stderr, "iSCSI implementation: iet\n");
+#endif
+	} else if (access(STGT_CMD_PATH, X_OK) == 0) {
+		iscsi_implementation = ISCSI_IMPL_STGT;
+#ifdef DEBUG
+		fprintf(stderr, "iSCSI implementation: stgt\n");
+#endif
+	} else if (stat(SYSFS_SCST, &eStat) == 0 &&
+		    S_ISDIR(eStat.st_mode)) {
+		iscsi_implementation = ISCSI_IMPL_SCST;
+#ifdef DEBUG
+		fprintf(stderr, "iSCSI implementation: scst\n");
+#endif
+	} else if (stat(SYSFS_LIO, &eStat) == 0 &&
+		    S_ISDIR(eStat.st_mode)) {
+		iscsi_implementation = ISCSI_IMPL_LIO;
+#ifdef DEBUG
+		fprintf(stderr, "iSCSI implementation: lio\n");
+#endif
+	}
+
+	if (iscsi_implementation != ISCSI_IMPL_NONE)
+		return (B_TRUE);
+
+	return (B_FALSE);
+}
+
+void
+libshare_iscsi_init(void)
+{
+	if (iscsi_available())
+		iscsi_fstype = register_fstype("iscsi", &iscsi_shareops);
+}
Index: pkg-zfs/lib/libshare/iscsi.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/iscsi.h	2016-05-10 22:53:08.707293021 +0000
@@ -0,0 +1,142 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011 Gunnar Beutner
+ */
+
+#include <sys/stat.h>
+#include <sys/list.h>
+
+#define	SYSFS_SCST			"/sys/kernel/scst_tgt"
+#define	SYSFS_LIO			"/sys/kernel/config/target"
+
+#define	PROC_IET_VOLUME			"/proc/net/iet/volume"
+#define	PROC_IET_SESSION		"/proc/net/iet/session"
+
+#define	IETM_CMD_PATH			"/usr/sbin/ietadm"
+#define	STGT_CMD_PATH			"/usr/sbin/tgtadm"
+
+#define	DOMAINNAME_FILE			"/etc/domainname"
+#define	DOMAINNAME_PROC			"/proc/sys/kernel/domainname"
+#define	TARGET_NAME_FILE		"/etc/iscsi_target_id"
+#define	EXTRA_ISCSI_SHARE_SCRIPT	"/sbin/zfs_share_iscsi"
+
+/*
+ * tid:1 name:iqn.2012-11.com.bayour:share.tests.iscsi1
+ *	lun:0 state:0 iotype:fileio iomode:wt blocks:31457280 blocksize:512 \
+ *	path:/dev/zvol/share/tests/iscsi1
+ */
+typedef struct iscsi_shareopts_s {
+	char	name[255];	/* Target IQN (name part) */
+	int	lun;		/* LUN number */
+	char	type[10];	/* disk or tape */
+	char	iomode[5];	/* wb, ro or wt */
+	int	blocksize;	/* 512, 1024, 2048 or 4096 */
+	char	initiator[255];	/* For LIO - Initiator ACL */
+	char	authname[255];
+	char	authpass[255];
+} iscsi_shareopts_t;
+
+/*
+ * When the share is active
+ *   debianzfs:~# cat /proc/net/iet/session
+ *   tid:1 name:iqn.2012-11.com.bayour:share.tests.iscsi1
+ *   	sid:281475651797504 initiator:iqn.1993-08.org.debian:01:e19b61b8377
+ *   		cid:0 ip:192.168.69.3 state:active hd:none dd:none
+ *
+ * When the share is inactive
+ *   debianzfs:~# cat /proc/net/iet/session
+ *   tid:1 name:iqn.2012-11.com.bayour:share.tests.iscsi1
+ */
+typedef struct iscsi_session_s {
+	int	tid;		/* Target ID */
+	char	name[255];	/* Target Name */
+
+	int	sid;		/* SID */
+	char	initiator[255];	/* Initiator Name */
+	int	cid;		/* CID */
+	char	ip[255];	/* IP to Initiator */
+	int	state;		/* State (active=1, inactive=0) */
+
+	char	hd[255];	/* ?? => hd:none */
+	char	dd[255];	/* ?? => dd:none */
+
+	list_node_t next;
+} iscsi_session_t;
+
+/*
+ * tid:1 name:iqn.2012-11.com.bayour:share.tests.iscsi1
+ * 	lun:0 state:0 iotype:fileio iomode:wt blocks:31457280 \
+ * 	blocksize:512 path:/dev/zvol/share/tests/iscsi1
+ */
+typedef struct iscsi_target_s {
+	int	tid;		/* Target ID */
+	char	iqn[255];	/* Target IQN */
+	char	name[255];	/* Target Name */
+	int	lun;		/* Target LUN */
+	int	state;		/* Target State */
+	char	iotype[8];	/* Target IO Type - fileio, */
+				/* blockio, nullio, disk, tape */
+	char	iomode[5];	/* Target IO Mode - wb, wt, ro */
+	int	blocks;		/* Target Size (blocks) */
+	int	blocksize;	/* Target Block Size (bytes) */
+	char	path[PATH_MAX];	/* Target Path */
+	char	device[16];	/* For SCST: The iSCSI device */
+
+	struct iscsi_session_s *session;
+
+	list_node_t next;
+} iscsi_target_t;
+
+typedef struct iscsi_dirs_s {
+	char		path[PATH_MAX];
+	char		entry[PATH_MAX];
+	struct stat	stats;
+
+	list_node_t next;
+} iscsi_dirs_t;
+
+typedef struct iscsi_users_s {
+	char		username[255];
+
+	list_node_t next;
+} iscsi_users_t;
+
+typedef struct iscsi_initiator_list_s {
+	char		initiator[255];
+	boolean_t	read_only;
+
+	list_node_t next;
+} iscsi_initiator_list_t;
+
+extern list_t all_iscsi_targets_list;
+extern sa_fstype_t *iscsi_fstype;
+
+void libshare_iscsi_init(void);
+iscsi_session_t *iscsi_session_list_alloc(void);
+int iscsi_get_shareopts(sa_share_impl_t, const char *, iscsi_shareopts_t **);
+int iscsi_generate_target(const char *, char *, size_t);
+int iscsi_read_sysfs_value(char *, char **);
+int iscsi_write_sysfs_value(char *, char *);
+list_t *iscsi_look_for_stuff(char *, const char *, boolean_t, int);
+list_t *iscsi_parse_initiator(iscsi_shareopts_t *);
Index: pkg-zfs/lib/libshare/iscsi_iet.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/iscsi_iet.c	2016-05-10 22:53:08.707293021 +0000
@@ -0,0 +1,604 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright (c) 2011-2014 Turbo Fredriksson <turbo@bayour.com>
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stddef.h>
+#include <libzfs.h>
+#include <libshare.h>
+#include <sys/fs/zfs.h>
+#include "libshare_impl.h"
+#include "iscsi.h"
+
+/*
+ * ============================================================
+ * Support functions
+ */
+
+/*
+ * Reads the proc file and register if a tid have a sid. Save the value in
+ * all_iscsi_targets_list->state
+ */
+static list_t *
+iscsi_retrieve_sessions_iet(void)
+{
+	FILE *iscsi_volumes_fp = NULL;
+	char *line, *token, *key, *value, *colon, *dup_value, buffer[512];
+	int buffer_len;
+	iscsi_session_t *session = NULL;
+	list_t *target_sessions = malloc(sizeof (list_t));
+	enum { ISCSI_SESSION, ISCSI_SID, ISCSI_CID } type;
+
+	/* For storing the share info */
+	char *tid = NULL, *name = NULL, *sid = NULL, *initiator = NULL,
+		*cid = NULL, *ip = NULL, *state = NULL, *hd = NULL,
+		*dd = NULL;
+
+	list_create(target_sessions, sizeof (iscsi_session_t),
+		    offsetof(iscsi_session_t, next));
+
+	/* Open file with targets */
+	iscsi_volumes_fp = fopen(PROC_IET_SESSION, "r");
+	if (iscsi_volumes_fp == NULL)
+		exit(SA_SYSTEM_ERR);
+
+	/* Load the file... */
+	while (fgets(buffer, sizeof (buffer), iscsi_volumes_fp) != NULL) {
+		/* Trim trailing new-line character(s). */
+		buffer_len = strlen(buffer);
+		while (buffer_len > 0) {
+			buffer_len--;
+			if (buffer[buffer_len] == '\r' ||
+			    buffer[buffer_len] == '\n') {
+				buffer[buffer_len] = 0;
+			} else
+				break;
+		}
+
+		if (buffer[0] != '\t') {
+			/*
+			 * Line doesn't start with a TAB which means this is a
+			 * session definition
+			 */
+			line = buffer;
+			type = ISCSI_SESSION;
+
+			free(name);
+			free(tid);
+			free(sid);
+			free(cid);
+			free(ip);
+			free(initiator);
+			free(state);
+			free(hd);
+			free(dd);
+
+			name = tid = sid = cid = ip = NULL;
+			initiator = state = hd = dd = NULL;
+		} else if (buffer[0] == '\t' && buffer[1] == '\t') {
+			/* Start with two tabs - CID definition */
+			line = buffer + 2;
+			type = ISCSI_CID;
+		} else if (buffer[0] == '\t') {
+			/* Start with one tab - SID definition */
+			line = buffer + 1;
+			type = ISCSI_SID;
+		} else {
+			/* Unknown line - skip it. */
+			continue;
+		}
+
+		/* Get each option, which is separated by space */
+		/* token='tid:18' */
+		token = strtok(line, " ");
+		while (token != NULL) {
+			colon = strchr(token, ':');
+			if (colon == NULL)
+				goto next_sessions;
+
+			key = token;
+			value = colon + 1;
+			*colon = '\0';
+
+			dup_value = strdup(value);
+			if (dup_value == NULL)
+				exit(SA_NO_MEMORY);
+
+			if (type == ISCSI_SESSION) {
+				if (strcmp(key, "tid") == 0)
+					tid = dup_value;
+				else if (strcmp(key, "name") == 0)
+					name = dup_value;
+				else
+					free(dup_value);
+			} else if (type == ISCSI_SID) {
+				if (strcmp(key, "sid") == 0)
+					sid = dup_value;
+				else if (strcmp(key, "initiator") == 0)
+					initiator = dup_value;
+				else
+					free(dup_value);
+			} else {
+				if (strcmp(key, "cid") == 0)
+					cid = dup_value;
+				else if (strcmp(key, "ip") == 0)
+					ip = dup_value;
+				else if (strcmp(key, "state") == 0)
+					state = dup_value;
+				else if (strcmp(key, "hd") == 0)
+					hd = dup_value;
+				else if (strcmp(key, "dd") == 0)
+					dd = dup_value;
+				else
+					free(dup_value);
+			}
+
+next_sessions:
+			token = strtok(NULL, " ");
+		}
+
+		if (tid == NULL || sid == NULL || cid == NULL ||
+		    name == NULL || initiator == NULL || ip == NULL ||
+		    state == NULL || dd == NULL || hd == NULL)
+			continue; /* Incomplete session definition */
+
+		session = iscsi_session_list_alloc();
+		if (session == NULL)
+			exit(SA_NO_MEMORY);
+
+		/* Save the values in the struct */
+		session->tid = atoi(tid);
+		session->sid = atoi(sid);
+		session->cid = atoi(cid);
+
+		strncpy(session->name, name, sizeof (session->name));
+		strncpy(session->initiator, initiator,
+			sizeof (session->initiator));
+		strncpy(session->ip, ip, sizeof (session->ip));
+		strncpy(session->hd, hd, sizeof (session->hd));
+		strncpy(session->dd, dd, sizeof (session->dd));
+
+		if (strcmp(state, "active") == 0)
+			session->state = 1;
+		else
+			session->state = 0;
+
+#ifdef DEBUG
+		fprintf(stderr, "iscsi_retrieve_sessions: target=%s, tid=%d, "
+			"sid=%d, cid=%d, initiator=%s, ip=%s, state=%d\n",
+			session->name, session->tid, session->sid, session->cid,
+			session->initiator, session->ip, session->state);
+#endif
+
+		/* Append the sessions to the list of new sessions */
+		list_insert_tail(target_sessions, session);
+	}
+
+	if (iscsi_volumes_fp != NULL)
+		fclose(iscsi_volumes_fp);
+
+	free(name);
+	free(tid);
+	free(sid);
+	free(cid);
+	free(ip);
+	free(initiator);
+	free(state);
+	free(hd);
+	free(dd);
+
+	return (target_sessions);
+}
+
+/*
+ * ============================================================
+ * Core functions
+ */
+
+int
+iscsi_retrieve_targets_iet(void)
+{
+	FILE *iscsi_volumes_fp = NULL;
+	char buffer[512];
+	char *line, *token, *key, *value, *colon, *dup_value;
+	int rc = SA_OK, buffer_len;
+	iscsi_session_t *session;
+	list_t *sessions;
+	enum { ISCSI_TARGET, ISCSI_LUN } type;
+
+	/* For soring the targets */
+	char *tid = NULL, *name = NULL, *lun = NULL, *state = NULL;
+	char *iotype = NULL, *iomode = NULL, *blocks = NULL;
+	char *blocksize = NULL, *path = NULL;
+	iscsi_target_t *target;
+
+	/* Get all sessions */
+	sessions = iscsi_retrieve_sessions_iet();
+
+	/* Open file with targets */
+	iscsi_volumes_fp = fopen(PROC_IET_VOLUME, "r");
+	if (iscsi_volumes_fp == NULL)
+		return (SA_SYSTEM_ERR);
+
+	/* Load the file... */
+	while (fgets(buffer, sizeof (buffer), iscsi_volumes_fp) != NULL) {
+		/* Trim trailing new-line character(s). */
+		buffer_len = strlen(buffer);
+		while (buffer_len > 0) {
+			buffer_len--;
+			if (buffer[buffer_len] == '\r' ||
+			    buffer[buffer_len] == '\n') {
+				buffer[buffer_len] = 0;
+			} else
+				break;
+		}
+
+		if (buffer[0] != '\t') {
+			/*
+			 * Line doesn't start with a TAB which
+			 * means this is a target definition
+			 */
+			line = buffer;
+			type = ISCSI_TARGET;
+
+			free(tid);
+			free(name);
+			free(lun);
+			free(state);
+			free(iotype);
+			free(iomode);
+			free(blocks);
+			free(blocksize);
+			free(path);
+
+			tid = name = NULL;
+			lun = state = iotype = iomode = NULL;
+			blocks = blocksize = path = NULL;
+		} else {
+			/* LUN definition */
+			line = buffer + 1;
+			type = ISCSI_LUN;
+		}
+
+		/* Get each option, which is separated by space */
+		/* token='tid:18' */
+		token = strtok(line, " ");
+		while (token != NULL) {
+			colon = strchr(token, ':');
+			if (colon == NULL)
+				goto next_targets;
+
+			key = token;
+			value = colon + 1;
+			*colon = '\0';
+
+			dup_value = strdup(value);
+
+			if (dup_value == NULL)
+				exit(SA_NO_MEMORY);
+
+			if (type == ISCSI_TARGET) {
+				if (strcmp(key, "tid") == 0)
+					tid = dup_value;
+				else if (strcmp(key, "name") == 0)
+					name = dup_value;
+				else
+					free(dup_value);
+			} else {
+				if (strcmp(key, "lun") == 0)
+					lun = dup_value;
+				else if (strcmp(key, "state") == 0)
+					state = dup_value;
+				else if (strcmp(key, "iotype") == 0)
+					iotype = dup_value;
+				else if (strcmp(key, "iomode") == 0)
+					iomode = dup_value;
+				else if (strcmp(key, "blocks") == 0)
+					blocks = dup_value;
+				else if (strcmp(key, "blocksize") == 0)
+					blocksize = dup_value;
+				else if (strcmp(key, "path") == 0)
+					path = dup_value;
+				else
+					free(dup_value);
+			}
+
+next_targets:
+			token = strtok(NULL, " ");
+		}
+
+		if (type != ISCSI_LUN)
+			continue;
+
+		if (tid == NULL || name == NULL || lun == NULL ||
+		    state == NULL || iotype == NULL || iomode == NULL ||
+		    blocks == NULL || blocksize == NULL || path == NULL)
+			continue; /* Incomplete target definition */
+
+		target = (iscsi_target_t *) malloc(sizeof (iscsi_target_t));
+		if (target == NULL) {
+			rc = SA_NO_MEMORY;
+			goto retrieve_targets_iet_out;
+		}
+
+		/* Save the values in the struct */
+		target->tid = atoi(tid);
+		target->lun = atoi(lun);
+		target->state = atoi(state);
+		target->blocks = atoi(blocks);
+		target->blocksize = atoi(blocksize);
+
+		strncpy(target->name,	name,	sizeof (target->name));
+		strncpy(target->path,	path,	sizeof (target->path));
+		strncpy(target->iotype,	iotype,	sizeof (target->iotype));
+		strncpy(target->iomode,	iomode,	sizeof (target->iomode));
+
+		/* Link the session here */
+		target->session = NULL;
+		for (session = list_head(sessions);
+		    session != NULL;
+		    session = list_next(sessions, session)) {
+			if (session->tid == target->tid) {
+				target->session = session;
+				list_link_init(&target->session->next);
+
+				break;
+			}
+		}
+
+#ifdef DEBUG
+		fprintf(stderr, "iscsi_retrieve_targets_iet: target=%s, "
+			"tid=%d, lun=%d, path=%s, active=%d\n", target->name,
+			target->tid, target->lun, target->path,
+			target->session ? target->session->state : -1);
+#endif
+
+		/* Append the target to the list of new targets */
+		list_insert_tail(&all_iscsi_targets_list, target);
+	}
+
+retrieve_targets_iet_out:
+	if (iscsi_volumes_fp != NULL)
+		fclose(iscsi_volumes_fp);
+
+	free(tid);
+	free(name);
+	free(lun);
+	free(state);
+	free(iotype);
+	free(iomode);
+	free(blocks);
+	free(blocksize);
+	free(path);
+
+	return (rc);
+}
+
+int
+iscsi_enable_share_one_iet(sa_share_impl_t impl_share, int tid)
+{
+	char *argv[10], params[255], tid_s[11], lun_s[11];
+	char *shareopts;
+	iscsi_shareopts_t *opts;
+	int rc, ret;
+#ifdef DEBUG
+	int i;
+#endif
+
+	opts = (iscsi_shareopts_t *) malloc(sizeof (iscsi_shareopts_t));
+	if (opts == NULL)
+		return (SA_NO_MEMORY);
+
+	/* Get any share options */
+	shareopts = FSINFO(impl_share, iscsi_fstype)->shareopts;
+	rc = iscsi_get_shareopts(impl_share, shareopts, &opts);
+	if (rc < 0) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+#ifdef DEBUG
+	fprintf(stderr, "iscsi_enable_share_one_iet: name=%s, tid=%d, "
+		"sharepath=%s, iomode=%s, type=%s, lun=%d, blocksize=%d, "
+		"authname=%s, authpass=%s\n",
+		opts->name, tid, impl_share->sharepath, opts->iomode,
+		opts->type, opts->lun, opts->blocksize, opts->authname,
+		opts->authpass);
+#endif
+
+	/*
+	 * ietadm --op new --tid $next --params Name=$iqn
+	 * ietadm --op new --tid $next --lun=0 --params \
+	 *   Path=/dev/zvol/$sharepath,Type=<fileio|blockio|nullio>
+	 */
+
+	/*
+	 * ======
+	 * PART 1 - do the (inital) share. No path etc...
+	 * CMD: ietadm --op new --tid <TID> --params <PARAMS>
+	 */
+	ret = snprintf(params, sizeof (params), "Name=%s",
+			opts->name);
+	if (ret < 0 || ret >= sizeof (params)) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/* int: between -2,147,483,648 and 2,147,483,647 => 10 chars + NUL */
+	ret = snprintf(tid_s, sizeof (tid_s), "%d", tid);
+	if (ret < 0 || ret >= sizeof (tid_s)) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	ret = snprintf(lun_s, sizeof (lun_s), "%d", opts->lun);
+	if (ret < 0 || ret >= sizeof (lun_s)) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	argv[0] = IETM_CMD_PATH;
+	argv[1] = (char *)"--op";
+	argv[2] = (char *)"new";
+	argv[3] = (char *)"--tid";
+	argv[4] = tid_s;
+	argv[5] = (char *)"--params";
+	argv[6] = params;
+	argv[7] = NULL;
+
+#ifdef DEBUG
+	fprintf(stderr, "CMD: ");
+	for (i = 0; i < 7; i++)
+		fprintf(stderr, "%s ", argv[i]);
+	fprintf(stderr, "\n");
+#endif
+
+	rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	if (rc != 0) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/*
+	 * ======
+	 * PART 2 - Add user acl
+	 * CMD: ietadm --op new --tid <TID> --user \
+	 *      --params=IncomingUser=iscsi-user,Password=secret
+	 */
+	if (strlen(opts->authname) && strlen(opts->authpass)) {
+		ret = snprintf(params, sizeof (params),
+				"IncomingUser=%s,Password=%s",
+				opts->authname, opts->authpass);
+		if (ret < 0 || ret >= sizeof (params)) {
+			free(opts);
+			return (SA_SYSTEM_ERR);
+		}
+
+		argv[5] = (char *)"--user";
+		argv[6] = (char *)"--params";
+		argv[7] = params;
+		argv[8] = NULL;
+
+#ifdef DEBUG
+		fprintf(stderr, "CMD: ");
+		for (i = 0; i < 8; i++)
+			fprintf(stderr, "%s ", argv[i]);
+		fprintf(stderr, "\n");
+#endif
+
+		rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+		if (rc != 0) {
+			free(opts);
+			return (SA_SYSTEM_ERR);
+		}
+	}
+
+	/*
+	 * ======
+	 * PART 3 - Set share path and lun.
+	 * CMD: ietadm --op new --tid <TID> --lun <LUN> --params <PARAMS>
+	 */
+	ret = snprintf(params, sizeof (params),
+			"Path=%s,Type=%s,iomode=%s,BlockSize=%d",
+			impl_share->sharepath, opts->type, opts->iomode,
+			opts->blocksize);
+	if (ret < 0 || ret >= sizeof (params)) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	argv[5] = (char *)"--lun";
+	argv[6] = lun_s;
+	argv[7] = (char *)"--params";
+	argv[8] = params;
+	argv[9] = NULL;
+
+#ifdef DEBUG
+	fprintf(stderr, "CMD: ");
+	for (i = 0; i < 9; i++)
+		fprintf(stderr, "%s ", argv[i]);
+	fprintf(stderr, "\n");
+#endif
+
+	rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	if (rc != 0) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/*
+	 * ======
+	 * PART 4 - Run local update script.
+	 */
+	if (access(EXTRA_ISCSI_SHARE_SCRIPT, X_OK) == 0) {
+		/* CMD: /sbin/zfs_share_iscsi <TID> */
+		argv[0] = (char *)EXTRA_ISCSI_SHARE_SCRIPT;
+		argv[1] = tid_s;
+		argv[2] = NULL;
+
+#ifdef DEBUG
+		fprintf(stderr, "CMD: ");
+		for (i = 0; i < 2; i++)
+			fprintf(stderr, "%s ", argv[i]);
+		fprintf(stderr, "\n");
+#endif
+
+		/* Ignore any error from script - "fire and forget" */
+		libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	}
+
+	free(opts);
+	return (SA_OK);
+}
+
+int
+iscsi_disable_share_one_iet(int tid)
+{
+	char *argv[6];
+	char tid_s[11];
+	int rc, ret;
+
+	/* int: between -2,147,483,648 and 2,147,483,647 => 10 chars + NUL */
+	ret = snprintf(tid_s, sizeof (tid_s), "%d", tid);
+	if (ret < 0 || ret >= sizeof (tid_s))
+		return (SA_SYSTEM_ERR);
+
+	/* CMD: ietadm --op delete --tid <TID> */
+	argv[0] = IETM_CMD_PATH;
+	argv[1] = (char *)"--op";
+	argv[2] = (char *)"delete";
+	argv[3] = (char *)"--tid";
+	argv[4] = tid_s;
+	argv[5] = NULL;
+
+#ifdef DEBUG
+	int i;
+	fprintf(stderr, "CMD: ");
+	for (i = 0; i < 5; i++)
+		fprintf(stderr, "%s ", argv[i]);
+	fprintf(stderr, "\n");
+#endif
+
+	rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	if (rc != 0)
+		return (SA_SYSTEM_ERR);
+	else
+		return (SA_OK);
+}
Index: pkg-zfs/lib/libshare/iscsi_lio.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/iscsi_lio.c	2016-05-10 22:53:08.711292970 +0000
@@ -0,0 +1,1017 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright (c) 2011-2014 Turbo Fredriksson <turbo@bayour.com>
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stddef.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include <libzfs.h>
+#include <libshare.h>
+#include <sys/fs/zfs.h>
+#include <libgen.h>
+#include "libshare_impl.h"
+#include "iscsi.h"
+
+/* Defined in iscsi_scst.c - COULD move it to iscsi.c, but... */
+extern list_t *iscsi_look_for_stuff(char *, const char *, boolean_t, int);
+
+/*
+ * ============================================================
+ * Support functions
+ */
+
+static const char *
+iscsi_generate_lio_serialno(void)
+{
+	static char string[34];
+	static const char valid_salts[] =
+		"abcdefghijklmnopqrstuvwxyz"
+		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+		"0123456789";
+	unsigned long i;
+	struct timeval tv;
+
+	/* Seed number for rand() */
+	gettimeofday(&tv, NULL);
+	srand((tv.tv_sec ^ tv.tv_usec) + getpid());
+
+	/* ASCII characters only */
+	for (i = 0; i < sizeof (string) - 1; i++)
+		string[i] = valid_salts[rand() % (sizeof (valid_salts) - 1)];
+	string[ i ] = '\0';
+
+	return (string);
+}
+
+/* Mabye put in iscsi.c or libshare.c, but so far it's only used here */
+static const char *
+iscsi_get_ipaddress(void)
+{
+	int rc;
+	char hostname[1024];
+	static char addrstr[100];
+	struct addrinfo *result;
+	void *ptr = NULL;
+
+	/* Get the hostname */
+	if (gethostname(hostname, 1024) != 0)
+		return (NULL);
+
+	/* resolve the domain name into a list of addresses */
+	rc = getaddrinfo(hostname, NULL, NULL, &result);
+	if (rc != 0)
+		return (NULL);
+
+	inet_ntop(result->ai_family, result->ai_addr->sa_data, addrstr, 100);
+	switch (result->ai_family) {
+	case AF_INET:
+		ptr = &((struct sockaddr_in *) result->ai_addr)->sin_addr;
+		break;
+	case AF_INET6:
+		ptr = &((struct sockaddr_in6 *) result->ai_addr)->sin6_addr;
+		break;
+	}
+	inet_ntop(result->ai_family, ptr, addrstr, 100);
+
+	freeaddrinfo(result);
+	return (addrstr);
+}
+
+// TODO
+static list_t *
+iscsi_retrieve_sessions_lio(void)
+{
+	list_t *target_sessions = malloc(sizeof (list_t));
+
+	list_create(target_sessions, sizeof (iscsi_session_t),
+		    offsetof(iscsi_session_t, next));
+
+// $SYSFS/iscsi/IQN/tpgt_TID/acls/INITIATOR/info
+// => No active iSCSI Session for Initiator Endpoint: INITIATOR
+// OR:
+// => InitiatorName: INITIATOR
+//    InitiatorAlias:
+//    LIO Session ID: 2   ISID: 0x80 12 34 56 dd 65  TSIH: 2  SessionType: Normal
+//    Session State: TARG_SESS_STATE_LOGGED_IN
+//    ---------------------[iSCSI Session Values]-----------------------
+//      CmdSN/WR  :  CmdSN/WC  :  ExpCmdSN  :  MaxCmdSN  :     ITT    :     TTT
+//     0x00000010   0x00000010   0x00001f53   0x00001f62   0x531f0000   0x00000d81
+//    ----------------------[iSCSI Connections]-------------------------
+//    CID: 1  Connection State: TARG_CONN_STATE_LOGGED_IN
+//       Address 192.168.69.3 TCP  StatSN: 0x1a00d3e6
+
+	return (target_sessions);
+}
+
+/* Setup the device part of a target */
+static int
+iscsi_setup_device_lio(sa_share_impl_t impl_share, iscsi_shareopts_t *opts,
+	int tid, const char *serno)
+{
+	int ret;
+	char path1[PATH_MAX], buffer[255];
+	mode_t dirmode = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH;
+
+	/*
+	 * ======
+	 * PART 1a - Setup the path
+	 */
+	ret = snprintf(path1, sizeof (path1), "%s/core/%s_%d/%s",
+			SYSFS_LIO, opts->type, tid, opts->name);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+#if DEBUG >= 2
+	fprintf(stderr, "mkdir -p %s\n", path1);
+#endif
+	if ((mkdirp(path1, dirmode) < 0) && (errno != EEXIST)) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/*
+	 * ======
+	 * PART 1b1 - set device
+	 */
+	ret = snprintf(path1, sizeof (path1), "%s/core/%s_%d/%s/udev_path",
+			SYSFS_LIO, opts->type, tid, opts->name);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+	ret = snprintf(buffer, sizeof (buffer), "%s",
+		    impl_share->sharepath);
+	if (ret < 0 || ret >= sizeof (buffer))
+		return (SA_SYSTEM_ERR);
+
+	if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+		return (SA_NO_MEMORY);
+
+	/*
+	 * ======
+	 * PART 1b2 - set device
+	 */
+	ret = snprintf(path1, sizeof (path1), "%s/core/%s_%d/%s/control",
+			SYSFS_LIO, opts->type, tid, opts->name);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+	if (strcmp(opts->type, "iblock") == 0) {
+		ret = snprintf(buffer, sizeof (buffer), "udev_path=%s",
+			impl_share->sharepath);
+	} else if (strcmp(opts->type, "fileio") == 0) {
+		ret = snprintf(buffer, sizeof (buffer), "fd_dev_name=%s",
+			impl_share->sharepath);
+	} else
+		/* Invalid type */
+		ret = -1;
+	if (ret < 0 || ret >= sizeof (buffer))
+		return (SA_SYSTEM_ERR);
+
+	if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+		return (SA_NO_MEMORY);
+
+	/*
+	 * ======
+	 * PART 1c2 - Set serial number
+	 */
+	ret = snprintf(path1, sizeof (path1),
+			"%s/core/%s_%d/%s/wwn/vpd_unit_serial",
+			SYSFS_LIO, opts->type, tid, opts->name);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+	ret = snprintf(buffer, sizeof (buffer), "%s", serno);
+	if (ret < 0 || ret >= sizeof (buffer))
+		return (SA_SYSTEM_ERR);
+
+	if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+		return (SA_NO_MEMORY);
+
+	/*
+	 * ======
+	 * PART 1d - Enable
+	 */
+	ret = snprintf(path1, sizeof (path1),
+			"%s/core/%s_%d/%s/enable",
+			SYSFS_LIO, opts->type, tid, opts->name);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+	strcpy(buffer, "1");
+
+	if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+		return (SA_NO_MEMORY);
+
+	/*
+	 * ======
+	 * PART 1e - Set block size
+	 */
+	ret = snprintf(path1, sizeof (path1),
+			"%s/core/%s_%d/%s/attrib/block_size",
+			SYSFS_LIO, opts->type, tid, opts->name);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+	ret = snprintf(buffer, sizeof (buffer), "%d",
+			opts->blocksize);
+	if (ret < 0 || ret >= sizeof (buffer))
+		return (SA_SYSTEM_ERR);
+
+	if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+		return (SA_NO_MEMORY);
+
+	return (SA_OK);
+}
+
+/* Setup the iqn/iscsi part of a target */
+static int
+iscsi_setup_iqn_lio(sa_share_impl_t impl_share, iscsi_shareopts_t *opts,
+	char *iqn, int tid, const char *serno)
+{
+	int ret;
+	char path1[PATH_MAX], path2[PATH_MAX], buffer[255];
+	const char *ip;
+	mode_t dirmode = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH;
+
+	/*
+	 * ======
+	 * PART 2a2 - Get IP address
+	 */
+	ip = iscsi_get_ipaddress();
+
+	/*
+	 * ======
+	 * PART 2a3 - Setup path
+	 */
+	ret = snprintf(path1, sizeof (path1),
+			"%s/iscsi/%s/tpgt_%d/np/%s:3260",
+			SYSFS_LIO, iqn, tid, ip);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+#if DEBUG >= 2
+	fprintf(stderr, "mkdir -p %s\n", path1);
+#endif
+	if ((mkdirp(path1, dirmode) < 0) && (errno != EEXIST)) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/*
+	 * ======
+	 * PART 2b - Setup symbolic link paths
+	 */
+	ret = snprintf(path1, sizeof (path1),
+			"%s/iscsi/%s/tpgt_%d/lun/lun_%d",
+			SYSFS_LIO, iqn, tid, opts->lun);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+#if DEBUG >= 2
+	fprintf(stderr, "mkdir -p %s\n", path1);
+#endif
+	if ((mkdirp(path1, dirmode) < 0) && (errno != EEXIST)) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/*
+	 * ======
+	 * PART 2b - Create symbolic link
+	 */
+	ret = snprintf(path1, sizeof (path1), "%s/core/%s_%d/%s",
+			SYSFS_LIO, opts->type, tid, opts->name);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+	ret = snprintf(path2, sizeof (path2),
+			"%s/iscsi/%s/tpgt_%d/lun/lun_%d/%s",
+			SYSFS_LIO, iqn, tid, opts->lun, serno);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+#if DEBUG >= 2
+	fprintf(stderr, "ln -s %s %s\n", path1, path2);
+#endif
+	if (symlink(path1, path2) != 0)
+		return (SA_SYSTEM_ERR);
+
+	/*
+	 * ======
+	 * PART 2c - Disable enforce_discovery_auth
+	 */
+	ret = snprintf(path1, sizeof (path1),
+			"%s/iscsi/discovery_auth/enforce_discovery_auth",
+			SYSFS_LIO);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+	strcpy(buffer, "0");
+
+	if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+		return (SA_NO_MEMORY);
+
+	return (SA_OK);
+}
+
+/* Setup the acl/mapped lun part of a target */
+static int
+iscsi_setup_acl_lio(sa_share_impl_t impl_share, iscsi_shareopts_t *opts,
+	char *iqn, int tid, const char *serno)
+{
+	int ret;
+	char path1[PATH_MAX], path2[PATH_MAX], buffer[255];
+	mode_t dirmode = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH;
+	iscsi_initiator_list_t *initiator;
+	list_t *initiators;
+
+	/* Parse initiators option */
+	initiators = iscsi_parse_initiator(opts);
+	if (list_is_empty(initiators))
+		return (SA_OK);
+	for (initiator = list_head(initiators);
+		initiator != NULL;
+		initiator = list_next(initiators, initiator)) {
+
+		/*
+		 * ======
+		 * PART 3a - Create initiator ACL directory
+		 */
+		ret = snprintf(path1, sizeof (path1),
+				"%s/iscsi/%s/tpgt_%d/acls/%s/lun_%d",
+				SYSFS_LIO, iqn, tid, initiator->initiator,
+				opts->lun);
+		if (ret < 0 || ret >= sizeof (path1))
+			return (SA_SYSTEM_ERR);
+
+#if DEBUG >= 2
+		fprintf(stderr, "mkdir -p %s\n", path1);
+#endif
+		if ((mkdirp(path1, dirmode) < 0) && (errno != EEXIST)) {
+			free(opts);
+			return (SA_SYSTEM_ERR);
+		}
+
+		/*
+		 * ======
+		 * PART 3b - Set default cmdsn_depth
+		 */
+		ret = snprintf(path1, sizeof (path1),
+				"%s/iscsi/%s/tpgt_%d/acls/%s/cmdsn_depth",
+				SYSFS_LIO, iqn, tid, initiator->initiator);
+		if (ret < 0 || ret >= sizeof (path1))
+			return (SA_SYSTEM_ERR);
+
+		strcpy(buffer, "16");
+
+		if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+			return (SA_NO_MEMORY);
+
+		/*
+		 * ======
+		 * PART 3c - Create symbolic link
+		 *
+		 * CMD: ln -s SYSFS_LIO/iscsi/IQN/tpgt_TID/lun/lun_LUN	\
+		 *	SYSFS_LIO/iscsi/IQN/tpgt_TID/acls/I_IQN/lun_LUn/SERNO
+		 */
+		ret = snprintf(path1, sizeof (path1),
+				"%s/iscsi/%s/tpgt_%d/lun/lun_%d",
+				SYSFS_LIO, iqn, tid, opts->lun);
+		if (ret < 0 || ret >= sizeof (path1))
+			return (SA_SYSTEM_ERR);
+
+		ret = snprintf(path2, sizeof (path2),
+				"%s/iscsi/%s/tpgt_%d/acls/%s/lun_%d/%s",
+				SYSFS_LIO, iqn, tid, initiator->initiator,
+				opts->lun, serno);
+		if (ret < 0 || ret >= sizeof (path1))
+			return (SA_SYSTEM_ERR);
+
+#if DEBUG >= 2
+		fprintf(stderr, "ln -s %s %s\n", path1, path2);
+#endif
+		if (symlink(path1, path2) != 0)
+			return (SA_SYSTEM_ERR);
+
+		/*
+		 * ======
+		 * PART 3d - Set rw/ro mode
+		 */
+		ret = snprintf(path1, sizeof (path1),
+				"%s/iscsi/%s/tpgt_%d/acls/"
+				"%s/lun_%d/write_protect",
+				SYSFS_LIO, iqn, tid,
+				initiator->initiator, opts->lun);
+		if (ret < 0 || ret >= sizeof (path1))
+			return (SA_SYSTEM_ERR);
+
+		if (initiator->read_only)
+			strcpy(buffer, "1");
+		else
+			strcpy(buffer, "0");
+
+		if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+			return (SA_NO_MEMORY);
+
+		/*
+		 * ======
+		 * PART 3e - Set auth name and password
+		 */
+		if (strlen(opts->authname) && strlen(opts->authpass)) {
+			/* Set username */
+			ret = snprintf(path1, sizeof (path1),
+				"%s/iscsi/%s/tpgt_%d/acls/%s/auth/userid",
+				SYSFS_LIO, iqn, tid, initiator->initiator);
+			if (ret < 0 || ret >= sizeof (path1))
+				return (SA_SYSTEM_ERR);
+
+			strcpy(buffer, opts->authname);
+
+			if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+				return (SA_NO_MEMORY);
+
+			/* Set password */
+			ret = snprintf(path1, sizeof (path1),
+				"%s/iscsi/%s/tpgt_%d/acls/%s/auth/password",
+				SYSFS_LIO, iqn, tid, initiator->initiator);
+			if (ret < 0 || ret >= sizeof (path1))
+				return (SA_SYSTEM_ERR);
+
+			strcpy(buffer, opts->authpass);
+
+			if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+				return (SA_NO_MEMORY);
+		}
+	}
+
+	return (SA_OK);
+}
+
+/*
+ * ============================================================
+ * Core functions
+ */
+
+/*
+ * find $SYSFS_LIO/core/{iblock,fileio}_* -maxdepth 0 -type d |
+ *   while read bstore; do
+ *     tid=$(echo $bstore | sed 's@.*_@@')
+ *     iqn=$(find $bstore/\* -maxdepth 0 -type d | sed 's@.*\/@@')
+ *     dev=$(cat $(find $bstore/\* -maxdepth 0 -type d)/udev_path)
+ *     lun=$(find $SYSFS_LIO/iscsi/$iqn/tpgt_1/lun/\* -maxdepth 0 -type d | \
+ *       sed 's@.*_@@')
+ *     blksize=$(cat $(find $bstore/\* -maxdepth 0 -type d)/attrib/block_size)
+ *   done
+ */
+int
+iscsi_retrieve_targets_lio(void)
+{
+	int ret;
+	char path[PATH_MAX], path2[PATH_MAX], *buffer = NULL;
+	iscsi_session_t *session;
+	iscsi_target_t *target;
+	iscsi_dirs_t *entry1, *entry2;
+	list_t *entries1, *entries2, *sessions;
+
+	/* For storing the share info */
+	char *tid = NULL, *lun = NULL, *blocksize = NULL, *name = NULL,
+		*dev_path = NULL, *iqn = NULL, *tmp = NULL;
+	char type[255];
+	/* TODO: *iotype = NULL, */
+
+	/*
+	 * ======
+	 * Retreive values we need
+	 */
+
+	/* Get all sessions */
+	sessions = iscsi_retrieve_sessions_lio();
+
+	/* DIR: /sys/kernel/config/target/core */
+	ret = snprintf(path, sizeof (path), "%s/core", SYSFS_LIO);
+	if (ret < 0 || ret >= sizeof (path))
+		return (SA_SYSTEM_ERR);
+
+	entries1 = iscsi_look_for_stuff(path, NULL, B_TRUE, 0);
+	for (entry1 = list_head(entries1);
+	    entry1 != NULL;
+	    entry1 = list_next(entries1, entry1)) {
+		/* DIR: .../{iblock,fileio}_[0-9]. */
+// fprintf(stderr, "ENTRY1=%s (%s)\n", entry1->entry, entry1->path); // DEBUG
+		// check entry1->entry for '{iblock,fileio}_*'
+		if (strncmp(entry1->entry, "iblock_", 7) == 0) {
+			strcpy(type, "iblock");
+			tid = strstr(entry1->entry, "iblock_") + 7;
+		} else if (strncmp(entry1->entry, "fileio_", 7) == 0) {
+			strcpy(type, "fileio");
+			tid = strstr(entry1->entry, "fileio_") + 7;
+		}
+
+		entries2 = iscsi_look_for_stuff(entry1->path, "iqn.",
+						B_TRUE, 4);
+		for (entry2 = list_head(entries2);
+		    entry2 != NULL;
+		    entry2 = list_next(entries2, entry2)) {
+// fprintf(stderr, "ENTRY2a=%s (%s)\n", entry2->entry, entry2->path); // DEBUG
+			/* DIR: .../iqn.[a-z0-9]* */
+			tmp = strdup(entry2->entry);
+			iqn = strtok(tmp, ":");
+
+			/* From the IQN, get the name (part after :) */
+			tmp = strdup(entry2->entry);
+			name = strstr(tmp, ":") + 1; /* Exclude the : char */
+
+			/* Get the dev path */
+			ret = snprintf(path2, sizeof (path2), "%s/udev_path",
+					entry2->path);
+			if (ret < 0 || ret >= sizeof (path2))
+				return (SA_SYSTEM_ERR);
+
+			if (iscsi_read_sysfs_value(path2, &buffer) != SA_OK)
+				return (SA_NO_MEMORY);
+			dev_path = strdup(buffer);
+
+			/* Get the block size */
+			ret = snprintf(path2, sizeof (path2),
+					"%s/attrib/block_size",
+					entry2->path);
+			if (ret < 0 || ret >= sizeof (path2))
+				return (SA_SYSTEM_ERR);
+
+			if (iscsi_read_sysfs_value(path2, &buffer) != SA_OK)
+				return (SA_NO_MEMORY);
+			blocksize = strdup(buffer);
+		}
+
+		ret = snprintf(path2, sizeof (path2),
+				"%s/iscsi/%s:%s/tpgt_%s/lun",
+				SYSFS_LIO, iqn, name, tid);
+		if (ret < 0 || ret >= sizeof (path2))
+			return (SA_SYSTEM_ERR);
+		entries2 = iscsi_look_for_stuff(path2, "lun_", B_TRUE, 4);
+		for (entry2 = list_head(entries2);
+		    entry2 != NULL;
+		    entry2 = list_next(entries2, entry2)) {
+// fprintf(stderr, "ENTRY2b=%s (%s)\n", entry2->entry, entry2->path); // DEBUG
+			lun = strstr(entry2->entry, "lun_") + 4;
+		}
+
+		/* TODO: Retrieve iomode */
+		/* TODO: Retrieve iotype */
+
+		/*
+		 * ======
+		 * Setup the list of targets
+		 */
+		target = (iscsi_target_t *)
+			malloc(sizeof (iscsi_target_t));
+		if (target == NULL)
+			return (SA_NO_MEMORY);
+
+#if DEBUG >= 2
+		fprintf(stderr, "iqn=%s\n", iqn);
+		fprintf(stderr, "  name=%s\n", name);
+		fprintf(stderr, "  dev=%s\n", dev_path);
+		fprintf(stderr, "  type=%s\n", type);
+		fprintf(stderr, "  tid=%s\n", tid);
+		fprintf(stderr, "  lun=%s\n", lun);
+		fprintf(stderr, "  blocksize=%s\n", blocksize);
+		fprintf(stderr, "\n");
+#endif
+
+		/*
+		 * NOTE: Sometimes 'lun' is null, because there is/was
+		 *       a problem with retrieving the value.
+		 */
+		if (tid != NULL && lun != NULL && blocksize != NULL &&
+			iqn != NULL && name != NULL && dev_path != NULL) {
+			target->tid = atoi(tid);
+			target->lun = atoi(lun);
+			target->blocksize = atoi(blocksize);
+
+			strncpy(target->iqn,	iqn,
+				sizeof (target->iqn));
+			strncpy(target->name,	name,
+				sizeof (target->name));
+			strncpy(target->path,	dev_path,
+				sizeof (target->path));
+			strncpy(target->iotype,	type,
+				sizeof (target->iotype));
+			/*
+			 * TODO
+			 * strncpy(target->iotype,	iotype,
+			 *	sizeof (target->iotype));
+			 * strncpy(target->iomode,	iomode,
+			 *	sizeof (target->iomode));
+			 */
+
+			/* Link the session here */
+			target->session = NULL;
+			for (session = list_head(sessions);
+				session != NULL;
+				session = list_next(sessions, session)) {
+				if (session->tid == target->tid) {
+					target->session = session;
+					list_link_init(
+						&target->session->next);
+
+					break;
+				}
+			}
+
+#ifdef DEBUG
+			fprintf(stderr, "iscsi_retrieve_targets_lio: "
+				"target=%s, tid=%d, lun=%d, path=%s\n",
+				target->name, target->tid, target->lun,
+				target->path);
+#endif
+
+			/* Append the target to the list of new trgs */
+			list_insert_tail(&all_iscsi_targets_list, target);
+		}
+	}
+
+	return (SA_OK);
+}
+
+int
+iscsi_enable_share_one_lio(sa_share_impl_t impl_share, int tid)
+{
+	int rc, ret;
+	char *argv[3], tid_s[11], iqn[255], path1[PATH_MAX], buffer[255];
+	const char *serno;
+	iscsi_shareopts_t *opts;
+	char *shareopts;
+
+	opts = (iscsi_shareopts_t *) malloc(sizeof (iscsi_shareopts_t));
+	if (opts == NULL)
+		return (SA_NO_MEMORY);
+
+	/* Get any share options */
+	shareopts = FSINFO(impl_share, iscsi_fstype)->shareopts;
+	rc = iscsi_get_shareopts(impl_share, shareopts, &opts);
+	if (rc < 0) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+#ifdef DEBUG
+	fprintf(stderr, "iscsi_enable_share_one_lio: name=%s, tid=%d, "
+		"sharepath=%s, iomode=%s, type=%s, lun=%d, blocksize=%d, "
+		"initiator_acl='%s'\n",
+		opts->name, tid, impl_share->sharepath, opts->iomode,
+		opts->type, opts->lun, opts->blocksize, opts->initiator);
+#endif
+
+	/* Generate serial number */
+	serno = iscsi_generate_lio_serialno();
+
+	/* Create IQN */
+	if (!opts->name) {
+		if (iscsi_generate_target(impl_share->dataset, iqn,
+					    sizeof (iqn)) != SA_OK)
+			return (SA_SYSTEM_ERR);
+	} else
+		strcpy(iqn, opts->name);
+
+	/*
+	 * ======
+	 * PART 1 - Setup device
+	 */
+	if (iscsi_setup_device_lio(impl_share, opts, tid, serno) != SA_OK)
+		return (SA_SYSTEM_ERR);
+
+	/*
+	 * ======
+	 * PART 2 - Setup IQN
+	 */
+	if (iscsi_setup_iqn_lio(impl_share, opts, iqn, tid, serno) != SA_OK)
+		return (SA_SYSTEM_ERR);
+
+	/*
+	 * ======
+	 * PART 3 - Setup ACL, Initiators
+	 */
+	if (iscsi_setup_acl_lio(impl_share, opts, iqn, tid, serno) != SA_OK)
+		return (SA_SYSTEM_ERR);
+
+	/*
+	 * ======
+	 * PART 4 - Enable IQN
+	 */
+	ret = snprintf(path1, sizeof (path1), "%s/iscsi/%s/tpgt_%d/enable",
+			SYSFS_LIO, iqn, tid);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+	strcpy(buffer, "1");
+
+	if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+		return (SA_NO_MEMORY);
+
+	/*
+	 * ======
+	 * PART 5 - If no authname/authpass, disable authentication
+	 */
+	if (!strlen(opts->authname)) {
+		ret = snprintf(path1, sizeof (path1),
+			"%s/iscsi/%s/tpgt_%d/attrib/authentication",
+			SYSFS_LIO, iqn, tid);
+		if (ret < 0 || ret >= sizeof (path1))
+			return (SA_SYSTEM_ERR);
+		strcpy(buffer, "0");
+		if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+			return (SA_NO_MEMORY);
+
+		ret = snprintf(path1, sizeof (path1),
+			"%s/iscsi/%s/tpgt_%d/attrib/generate_node_acls",
+			SYSFS_LIO, iqn, tid);
+		if (ret < 0 || ret >= sizeof (path1))
+			return (SA_SYSTEM_ERR);
+		strcpy(buffer, "1");
+		if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+			return (SA_NO_MEMORY);
+	}
+
+	/*
+	 * ======
+	 * PART 6 - Run local update script.
+	 */
+	ret = snprintf(tid_s, sizeof (tid_s), "%d", tid);
+	if (ret < 0 || ret >= sizeof (tid_s)) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	if (access(EXTRA_ISCSI_SHARE_SCRIPT, X_OK) == 0) {
+		/* CMD: /sbin/zfs_share_iscsi <TID> */
+		argv[0] = (char *)EXTRA_ISCSI_SHARE_SCRIPT;
+		argv[1] = tid_s;
+		argv[2] = NULL;
+
+#ifdef DEBUG
+		int i;
+		fprintf(stderr, "CMD: ");
+		for (i = 0; i < 2; i++)
+			fprintf(stderr, "%s ", argv[i]);
+		fprintf(stderr, "\n");
+#endif
+
+		/* Ignore any error from script - "fire and forget" */
+		libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	}
+
+	free(opts);
+	return (SA_OK);
+}
+
+int
+iscsi_disable_share_one_lio(int tid)
+{
+	int ret;
+	char path1[PATH_MAX], path2[PATH_MAX], buffer[255];
+	list_t *entries1, *entries2, *entries3;
+	iscsi_dirs_t *entry1, *entry2, *entry3;
+	iscsi_target_t *target;
+
+	for (target = list_head(&all_iscsi_targets_list);
+	    target != NULL;
+	    target = list_next(&all_iscsi_targets_list, target)) {
+		if (target->tid == tid) {
+#ifdef DEBUG
+			fprintf(stderr, "iscsi_disable_share_one_lio: "
+				"target=%s, tid=%d, path=%s\n",
+				target->name, target->tid, target->path);
+#endif
+
+			break;
+		}
+	}
+
+	/*
+	 * ======
+	 * PART 1 - Disable target
+	 * CMD: echo 0 > $SYSFS/iscsi/IQN/tpgt_TID/enable
+	 */
+	ret = snprintf(path1, sizeof (path1), "%s/iscsi/%s:%s/tpgt_%d/enable",
+			SYSFS_LIO, target->iqn, target->name, target->tid);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+	strcpy(buffer, "0");
+	if (iscsi_write_sysfs_value(path1, buffer) != SA_OK)
+		return (SA_NO_MEMORY);
+
+	/*
+	 * ======
+	 * PART 2 - Recursivly delete IQN directory.
+	 */
+
+	/* CMD: rmdir $SYSFS/iscsi/IQN/tpgt_TID/np/IP:PORT */
+	ret = snprintf(path1, sizeof (path1), "%s/iscsi/%s:%s/tpgt_%d/np",
+			SYSFS_LIO, target->iqn, target->name, target->tid);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+	entries1 = iscsi_look_for_stuff(path1, NULL, B_TRUE, 0);
+	for (entry1 = list_head(entries1);
+		entry1 != NULL;
+		entry1 = list_next(entries1, entry1)) {
+#ifdef DEBUG
+		fprintf(stderr, "CMD: rmdir(%s)\n", entry1->path);
+#endif
+		ret = rmdir(entry1->path);
+		if (ret < 0) {
+			fprintf(stderr, "ERR: Failed to remove %s\n",
+				entry1->path);
+			return (SA_SYSTEM_ERR);
+		}
+	}
+
+	/* CMD: rm    $SYSFS/iscsi/IQN/tpgt_TID/acls/INITIATOR/lun_LUN/LINK */
+	/* CMD: rmdir $SYSFS/iscsi/IQN/tpgt_TID/acls/INITIATOR/lun_LUN */
+	/* CMD: rmdir $SYSFS/iscsi/IQN/tpgt_TID/acls/INITIATOR */
+	ret = snprintf(path1, sizeof (path1), "%s/iscsi/%s:%s/tpgt_%d/acls",
+			SYSFS_LIO, target->iqn, target->name, target->tid);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+	entries1 = iscsi_look_for_stuff(path1, "iqn.", B_TRUE, 4);
+	for (entry1 = list_head(entries1);
+		entry1 != NULL;
+		entry1 = list_next(entries1, entry1)) {
+		entries2 = iscsi_look_for_stuff(entry1->path, "lun_",
+						B_TRUE, 4);
+		for (entry2 = list_head(entries2);
+			entry2 != NULL;
+			entry2 = list_next(entries2, entry2)) {
+			entries3 = iscsi_look_for_stuff(entry2->path, NULL,
+							B_FALSE, 0);
+			for (entry3 = list_head(entries3);
+				entry3 != NULL;
+				entry3 = list_next(entries3, entry3)) {
+#ifdef DEBUG
+				fprintf(stderr, "CMD: unlink(%s)\n",
+					entry3->path);
+#endif
+				ret = unlink(entry3->path);
+				if (ret < 0) {
+					fprintf(stderr, "ERR: Failed to remove "
+						"%s\n", entry3->path);
+					return (SA_SYSTEM_ERR);
+				}
+			}
+
+#ifdef DEBUG
+			fprintf(stderr, "CMD: rmdir(%s)\n", entry2->path);
+#endif
+			ret = rmdir(entry2->path);
+			if (ret < 0) {
+				fprintf(stderr, "ERR: Failed to remove %s\n",
+					entry2->path);
+				return (SA_SYSTEM_ERR);
+			}
+		}
+
+#ifdef DEBUG
+		fprintf(stderr, "CMD: rmdir(%s)\n", entry1->path);
+#endif
+		ret = rmdir(entry1->path);
+		if (ret < 0) {
+			fprintf(stderr, "ERR: Failed to remove %s\n",
+				entry1->path);
+			return (SA_SYSTEM_ERR);
+		}
+	}
+
+	/* CMD: rm    $SYSFS/iscsi/IQN/tpgt_TID/lun/lun_LUN/LINK */
+	/* CMD: rmdir $SYSFS/iscsi/IQN/tpgt_TID/lun/lun_LUN */
+	ret = snprintf(path1, sizeof (path1), "%s/iscsi/%s:%s/tpgt_%d/lun",
+			SYSFS_LIO, target->iqn, target->name, target->tid);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+
+	entries1 = iscsi_look_for_stuff(path1, "lun_", B_TRUE, 4);
+	for (entry1 = list_head(entries1);
+		entry1 != NULL;
+		entry1 = list_next(entries1, entry1)) {
+		ret = snprintf(path2, sizeof (path2),
+				"%s/iscsi/%s:%s/tpgt_%d/lun/%s",
+				SYSFS_LIO, target->iqn, target->name,
+				target->tid, entry1->entry);
+		if (ret < 0 || ret >= sizeof (path1))
+			return (SA_SYSTEM_ERR);
+
+		entries2 = iscsi_look_for_stuff(path2, NULL, B_FALSE, 0);
+		for (entry2 = list_head(entries2);
+			entry2 != NULL;
+			entry2 = list_next(entries2, entry2)) {
+#ifdef DEBUG
+			fprintf(stderr, "CMD: unlink(%s)\n", entry2->path);
+#endif
+			ret = unlink(entry2->path);
+			if (ret < 0) {
+				fprintf(stderr, "ERR: Failed to remove %s\n",
+					entry2->path);
+				return (SA_SYSTEM_ERR);
+			}
+		}
+
+#ifdef DEBUG
+		fprintf(stderr, "CMD: rmdir(%s)\n", entry1->path);
+#endif
+		ret = rmdir(entry1->path);
+		if (ret < 0) {
+			fprintf(stderr, "ERR: Failed to remove %s\n",
+				entry1->path);
+			return (SA_SYSTEM_ERR);
+		}
+	}
+
+	/* CMD: rmdir $SYSFS/iscsi/IQN/tpgt_TID */
+	ret = snprintf(path1, sizeof (path1), "%s/iscsi/%s:%s/tpgt_%d",
+			SYSFS_LIO, target->iqn, target->name, target->tid);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+#ifdef DEBUG
+		fprintf(stderr, "CMD: rmdir(%s)\n", path1);
+#endif
+	ret = rmdir(path1);
+	if (ret < 0) {
+		fprintf(stderr, "ERR: Failed to remove %s\n", path1);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/* CMD: rmdir $SYSFS/iscsi/IQN:NAME */
+	ret = snprintf(path1, sizeof (path1), "%s/iscsi/%s:%s",
+			SYSFS_LIO, target->iqn, target->name);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+#ifdef DEBUG
+		fprintf(stderr, "CMD: rmdir(%s)\n", path1);
+#endif
+	ret = rmdir(path1);
+	if (ret < 0) {
+		fprintf(stderr, "ERR: Failed to remove %s\n", path1);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/*
+	 * ======
+	 * PART 3 - Delete device backstore
+	 */
+
+	/* CMD: rmdir $SYSFS/core/iblock_TID/IQN:NAME */
+	ret = snprintf(path1, sizeof (path1), "%s/core/%s_%d/%s:%s",
+			SYSFS_LIO, target->iotype, target->tid,
+			target->iqn, target->name);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+#ifdef DEBUG
+		fprintf(stderr, "CMD: rmdir(%s)\n", path1);
+#endif
+	ret = rmdir(path1);
+	if (ret < 0) {
+		fprintf(stderr, "ERR: Failed to remove %s\n", path1);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/* CMD: rmdir $SYSFS/core/iblock_TID */
+	ret = snprintf(path1, sizeof (path1), "%s/core/%s_%d",
+			SYSFS_LIO, target->iotype, target->tid);
+	if (ret < 0 || ret >= sizeof (path1))
+		return (SA_SYSTEM_ERR);
+#ifdef DEBUG
+		fprintf(stderr, "CMD: rmdir(%s)\n", path1);
+#endif
+	ret = rmdir(path1);
+	if (ret < 0) {
+		fprintf(stderr, "ERR: Failed to remove %s\n", path1);
+		return (SA_SYSTEM_ERR);
+	}
+
+	return (SA_OK);
+}
Index: pkg-zfs/lib/libshare/iscsi_scst.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/iscsi_scst.c	2016-05-10 22:53:08.723292820 +0000
@@ -0,0 +1,818 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright (c) 2011-2014 Turbo Fredriksson <turbo@bayour.com>
+ *
+ * ZoL will read and modify appropriate files below /sys/kernel/scst_tgt.
+ * See iscsi_retrieve_targets_scst() for details.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stddef.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <libzfs.h>
+#include <libshare.h>
+#include <sys/fs/zfs.h>
+#include "libshare_impl.h"
+#include "iscsi.h"
+
+/*
+ * ============================================================
+ * Support functions
+ */
+
+/*
+ * Preferably we should use the dataset name here, but there's a limit
+ * of 16 characters...
+ */
+static void
+iscsi_generate_scst_device_name(char **device)
+{
+	char string[17];
+	static const char valid_salts[] =
+		"abcdefghijklmnopqrstuvwxyz"
+		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+		"0123456789";
+	unsigned long i;
+	struct timeval tv;
+
+	/* Mske sure that device is set */
+	assert(device != NULL);
+
+	/* Seed number for rand() */
+	gettimeofday(&tv, NULL);
+	srand((tv.tv_sec ^ tv.tv_usec) + getpid());
+
+	/* ASCII characters only */
+	for (i = 0; i < sizeof (string) - 1; i++)
+		string[i] = valid_salts[rand() % (sizeof (valid_salts) - 1)];
+	string[ i ] = '\0';
+
+	*device = strdup(string);
+}
+
+/*
+ * name:        $SYSFS/targets/iscsi/$name
+ * tid:         $SYSFS/targets/iscsi/$name/tid
+ * initiator:   $SYSFS/targets/iscsi/$name/sessions/$initiator/
+ * sid:         $SYSFS/targets/iscsi/$name/sessions/$initiator/sid
+ * cid:         $SYSFS/targets/iscsi/$name/sessions/$initiator/$ip/cid
+ * ip:          $SYSFS/targets/iscsi/$name/sessions/$initiator/$ip/ip
+ * state:       $SYSFS/targets/iscsi/$name/sessions/$initiator/$ip/state
+ */
+static list_t *
+iscsi_retrieve_sessions_scst(void)
+{
+	int ret;
+	char path[PATH_MAX], tmp_path[PATH_MAX], *buffer = NULL;
+	struct stat eStat;
+	iscsi_dirs_t *entry1, *entry2, *entry3;
+	iscsi_session_t *session = NULL;
+	list_t *entries1, *entries2, *entries3;
+	list_t *target_sessions = malloc(sizeof (list_t));
+
+	/* For storing the share info */
+	char *tid = NULL, *sid = NULL, *cid = NULL, *name = NULL,
+		*initiator = NULL, *ip = NULL, *state = NULL;
+
+	list_create(target_sessions, sizeof (iscsi_session_t),
+		    offsetof(iscsi_session_t, next));
+
+	/* DIR: $SYSFS/targets/iscsi/$name */
+	ret = snprintf(path, sizeof (path), "%s/targets/iscsi", SYSFS_SCST);
+	if (ret < 0 || ret >= sizeof (path))
+		return (target_sessions);
+
+	entries1 = iscsi_look_for_stuff(path, "iqn.", B_TRUE, 4);
+	if (!list_is_empty(entries1))
+		return (target_sessions);
+	for (entry1 = list_head(entries1);
+	    entry1 != NULL;
+	    entry1 = list_next(entries1, entry1)) {
+		/* DIR: $SYSFS/targets/iscsi/$name */
+
+		/* RETRIEVE name */
+		name = entry1->entry;
+
+		/* RETRIEVE tid */
+		ret = snprintf(tmp_path, sizeof (tmp_path), "%s/tid",
+			    entry1->path);
+		if (ret < 0 || ret >= sizeof (tmp_path))
+			goto iscsi_retrieve_sessions_scst_error;
+		if (iscsi_read_sysfs_value(tmp_path, &buffer) != SA_OK)
+			goto iscsi_retrieve_sessions_scst_error;
+		if (tid)
+			free(tid);
+		tid = buffer;
+		buffer = NULL;
+
+		ret = snprintf(path, sizeof (path), "%s/sessions",
+			    entry1->path);
+		if (ret < 0 || ret >= sizeof (path))
+			goto iscsi_retrieve_sessions_scst_error;
+
+		entries2 = iscsi_look_for_stuff(path, "iqn.", B_TRUE, 4);
+		if (!list_is_empty(entries2))
+			goto iscsi_retrieve_sessions_scst_error;
+		for (entry2 = list_head(entries2);
+		    entry2 != NULL;
+		    entry2 = list_next(entries2, entry2)) {
+			/* $SYSFS/targets/iscsi/$name/sessions/$initiator */
+
+			/* RETRIEVE initiator */
+			initiator = entry2->entry;
+
+			/* RETRIEVE sid */
+			ret = snprintf(tmp_path, sizeof (tmp_path), "%s/sid",
+				    entry2->path);
+			if (ret < 0 || ret >= sizeof (tmp_path))
+				goto iscsi_retrieve_sessions_scst_error;
+			if (iscsi_read_sysfs_value(tmp_path, &buffer) != SA_OK)
+				goto iscsi_retrieve_sessions_scst_error;
+			if (sid)
+				free(sid);
+			sid = buffer;
+			buffer = NULL;
+
+			entries3 = iscsi_look_for_stuff(entry2->path, NULL,
+							B_TRUE, 4);
+			if (!list_is_empty(entries3))
+				goto iscsi_retrieve_sessions_scst_error;
+			for (entry3 = list_head(entries3);
+			    entry3 != NULL;
+			    entry3 = list_next(entries3, entry3)) {
+				/*
+				 * $SYSFS/targets/iscsi/$name/sessions/
+				 *     $initiator/$ip
+				 */
+				ret = snprintf(path, sizeof (path), "%s/cid",
+					    entry3->path);
+				if (ret < 0 || ret >= sizeof (path))
+					goto iscsi_retrieve_sessions_scst_error;
+				if (stat(path, &eStat) == -1)
+					/* Not a IP directory */
+					break;
+
+				/* RETRIEVE ip */
+				ip = entry3->entry;
+
+				/* RETRIEVE cid */
+				ret = snprintf(tmp_path, sizeof (tmp_path),
+					    "%s/cid", entry3->path);
+				if (ret < 0 || ret >= sizeof (tmp_path))
+					goto iscsi_retrieve_sessions_scst_error;
+				if (iscsi_read_sysfs_value(tmp_path, &buffer)
+				    != SA_OK)
+					goto iscsi_retrieve_sessions_scst_error;
+				if (cid)
+					free(cid);
+				cid = buffer;
+				buffer = NULL;
+
+				/* RETRIEVE state */
+				ret = snprintf(tmp_path, sizeof (tmp_path),
+					    "%s/state", entry3->path);
+				if (ret < 0 || ret >= sizeof (tmp_path))
+					goto iscsi_retrieve_sessions_scst_error;
+				if (iscsi_read_sysfs_value(tmp_path, &buffer)
+				    != SA_OK)
+					goto iscsi_retrieve_sessions_scst_error;
+				if (state)
+					free(state);
+				state = buffer;
+				buffer = NULL;
+
+				/* SAVE values */
+				if (tid == NULL || sid == NULL || cid == NULL ||
+				    name == NULL || initiator == NULL ||
+				    ip == NULL || state == NULL)
+					continue; /* Incomplete session def */
+
+				session = iscsi_session_list_alloc();
+				if (session == NULL)
+					exit(SA_NO_MEMORY);
+
+				session->tid = atoi(tid);
+				session->sid = atoi(sid);
+				session->cid = atoi(cid);
+
+				strncpy(session->name, name,
+					sizeof (session->name));
+				strncpy(session->initiator, initiator,
+					sizeof (session->initiator));
+				strncpy(session->ip, ip,
+					sizeof (session->ip));
+
+				session->hd[0] = '\0';
+				session->dd[0] = '\0';
+
+				if (strncmp(state, "established", 11) == 0)
+					session->state = 1;
+				else
+					session->state = 0;
+
+#ifdef DEBUG
+				fprintf(stderr, "iscsi_retrieve_sessions: "
+					"target=%s, tid=%d, sid=%d, cid=%d, "
+					"initiator=%s, ip=%s, state=%d\n",
+					session->name, session->tid,
+					session->sid, session->cid,
+					session->initiator, session->ip,
+					session->state);
+#endif
+
+				/* Append the sessions to the list of new */
+				list_insert_tail(target_sessions, session);
+
+				/* Clear variables */
+				free(tid);
+				free(sid);
+				free(cid);
+				free(state);
+				name = tid = sid = cid = ip = NULL;
+				initiator = state = NULL;
+			}
+		}
+	}
+
+iscsi_retrieve_sessions_scst_error:
+	free(tid);
+	free(sid);
+	free(cid);
+	free(state);
+
+	return (target_sessions);
+}
+
+/*
+ * ============================================================
+ * Core functions
+ */
+
+int
+iscsi_retrieve_targets_scst(void)
+{
+	char path[PATH_MAX], tmp_path[PATH_MAX], *buffer, *link = NULL;
+	int rc = SA_SYSTEM_ERR, ret;
+	iscsi_dirs_t *entry1, *entry2, *entry3;
+	list_t *entries1, *entries2, *entries3;
+	iscsi_target_t *target;
+	iscsi_session_t *session;
+	list_t *sessions;
+
+	/* For storing the share info */
+	char *tid = NULL, *lun = NULL, *state = NULL, *blocksize = NULL;
+	char *name = NULL, *iotype = NULL, *dev_path = NULL, *device = NULL;
+
+	/* Get all sessions */
+	sessions = iscsi_retrieve_sessions_scst();
+
+	/* DIR: /sys/kernel/scst_tgt/targets */
+	ret = snprintf(path, sizeof (path), "%s/targets", SYSFS_SCST);
+	if (ret < 0 || ret >= sizeof (path))
+		return (SA_SYSTEM_ERR);
+
+	entries1 = iscsi_look_for_stuff(path, "iscsi", B_TRUE, 0);
+	for (entry1 = list_head(entries1);
+	    entry1 != NULL;
+	    entry1 = list_next(entries1, entry1)) {
+		entries2 = iscsi_look_for_stuff(entry1->path, "iqn.",
+						B_TRUE, 4);
+		for (entry2 = list_head(entries2);
+		    entry2 != NULL;
+		    entry2 = list_next(entries2, entry2)) {
+			/* DIR: /sys/kernel/scst_tgt/targets/iscsi/iqn.* */
+
+			/* Save the share name */
+			name = entry2->entry;
+
+			/* RETRIEVE state */
+			ret = snprintf(tmp_path, sizeof (tmp_path),
+					"%s/enabled", entry2->path);
+			if (ret < 0 || ret >= sizeof (tmp_path))
+				goto retrieve_targets_scst_out;
+			if (iscsi_read_sysfs_value(tmp_path, &buffer) != SA_OK)
+				goto retrieve_targets_scst_out;
+			state = buffer;
+			buffer = NULL;
+
+			/* RETRIEVE tid */
+			ret = snprintf(tmp_path, sizeof (tmp_path), "%s/tid",
+					entry2->path);
+			if (ret < 0 || ret >= sizeof (tmp_path))
+				goto retrieve_targets_scst_out;
+			if (iscsi_read_sysfs_value(tmp_path, &buffer) != SA_OK)
+				goto retrieve_targets_scst_out;
+			tid = buffer;
+			buffer = NULL;
+
+			/* RETRIEVE lun(s) */
+			ret = snprintf(tmp_path, sizeof (tmp_path),
+					"%s/luns", entry2->path);
+			if (ret < 0 || ret >= sizeof (tmp_path))
+				goto retrieve_targets_scst_out;
+
+			entries3 = iscsi_look_for_stuff(tmp_path, NULL,
+							B_TRUE, 0);
+			for (entry3 = list_head(entries3);
+			    entry3 != NULL;
+			    entry3 = list_next(entries3, entry3)) {
+				lun = entry3->entry;
+
+				/* RETRIEVE blocksize */
+				ret = snprintf(tmp_path, sizeof (tmp_path),
+						"%s/luns/%s/device/blocksize",
+						entry2->path, lun);
+				if (ret < 0 || ret >= sizeof (tmp_path))
+					goto retrieve_targets_scst_out;
+				if (iscsi_read_sysfs_value(tmp_path, &buffer)
+				    != SA_OK)
+					goto retrieve_targets_scst_out;
+				blocksize = buffer;
+				buffer = NULL;
+
+				/* RETRIEVE block device path */
+				ret = snprintf(tmp_path, sizeof (tmp_path),
+						"%s/luns/%s/device/filename",
+						entry2->path, lun);
+				if (ret < 0 || ret >= sizeof (tmp_path))
+					goto retrieve_targets_scst_out;
+				if (iscsi_read_sysfs_value(tmp_path, &buffer)
+				    != SA_OK)
+					goto retrieve_targets_scst_out;
+				dev_path = buffer;
+				buffer = NULL;
+
+				/*
+				 * RETRIEVE scst device name
+				 * trickier: '6550a239-iscsi1' (s/.*-//)
+				 */
+				ret = snprintf(tmp_path, sizeof (tmp_path),
+					    "%s/luns/%s/device/t10_dev_id",
+					    entry2->path, lun);
+				if (ret < 0 || ret >= sizeof (tmp_path))
+					goto retrieve_targets_scst_out;
+				if (iscsi_read_sysfs_value(tmp_path, &buffer)
+				    != SA_OK)
+					goto retrieve_targets_scst_out;
+				device = strstr(buffer, "-") + 1;
+				buffer = NULL;
+
+				/*
+				 * RETRIEVE iotype
+				 * tricker: it's only availible in the
+				 * link.
+				 *
+				 * $SYSFS/targets/iscsi/$name/luns/0/
+				 *   device/handler
+				 * => /sys/kernel/scst_tgt/handlers/
+				 *   vdisk_blockio
+				 */
+				ret = snprintf(tmp_path, sizeof (tmp_path),
+						"%s/luns/%s/device/handler",
+						entry2->path, lun);
+				if (ret < 0 || ret >= sizeof (tmp_path))
+					goto retrieve_targets_scst_out;
+
+				link = (char *) calloc(PATH_MAX, 1);
+				if (link == NULL) {
+					rc = SA_NO_MEMORY;
+					goto retrieve_targets_scst_out;
+				}
+
+				if (readlink(tmp_path, link, PATH_MAX) == -1) {
+					rc = errno;
+					goto retrieve_targets_scst_out;
+				}
+				link[strlen(link)] = '\0';
+				iotype = strstr(link, "_") + 1;
+
+				/* TODO: Retrieve iomode */
+
+				target = (iscsi_target_t *)
+					malloc(sizeof (iscsi_target_t));
+				if (target == NULL) {
+					rc = SA_NO_MEMORY;
+					goto retrieve_targets_scst_out;
+				}
+
+				target->tid = atoi(tid);
+				target->lun = atoi(lun);
+				target->state = atoi(state);
+				target->blocksize = atoi(blocksize);
+
+				strncpy(target->name,	name,
+					sizeof (target->name));
+				strncpy(target->path,	dev_path,
+					sizeof (target->path));
+				strncpy(target->device,	device,
+					sizeof (target->device));
+				strncpy(target->iotype,	iotype,
+					sizeof (target->iotype));
+				/*
+				 * TODO
+				 * strncpy(target->iomode,	iomode,
+				 *	sizeof (target->iomode));
+				 */
+
+				/* Link the session here */
+				target->session = NULL;
+				for (session = list_head(sessions);
+				    session != NULL;
+				    session = list_next(sessions, session)) {
+					if (session->tid == target->tid) {
+						target->session = session;
+						list_link_init(
+						    &target->session->next);
+
+						break;
+					}
+				}
+
+#ifdef DEBUG
+				fprintf(stderr, "iscsi_retrieve_targets_scst: "
+					"target=%s, tid=%d, lun=%d, path=%s\n",
+					target->name, target->tid, target->lun,
+					target->path);
+#endif
+
+				/* Append the target to the list of new trgs */
+				list_insert_tail(&all_iscsi_targets_list,
+					    target);
+			}
+		}
+	}
+
+	free(link);
+
+	return (SA_OK);
+
+retrieve_targets_scst_out:
+	free(link);
+
+	return (rc);
+}
+
+/* NOTE: TID is not use with SCST - it's autogenerated at create time. */
+int
+iscsi_enable_share_one_scst(sa_share_impl_t impl_share, int tid)
+{
+	int rc, ret;
+	char *argv[3], *shareopts, *device, buffer[255], path[PATH_MAX];
+	iscsi_shareopts_t *opts;
+	iscsi_initiator_list_t *initiator;
+	list_t *initiators;
+
+#ifdef DEBUG
+	fprintf(stderr, "iscsi_enable_share_one_scst: tid=%d, sharepath=%s\n",
+		tid, impl_share->sharepath);
+#endif
+
+	opts = (iscsi_shareopts_t *) malloc(sizeof (iscsi_shareopts_t));
+	if (opts == NULL)
+		return (SA_NO_MEMORY);
+
+	/* Get any share options */
+	shareopts = FSINFO(impl_share, iscsi_fstype)->shareopts;
+	rc = iscsi_get_shareopts(impl_share, shareopts, &opts);
+	if (rc != SA_OK) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/* Generate a scst device name from the dataset name */
+	iscsi_generate_scst_device_name(&device);
+
+	/* Parse 'initiator=...' option */
+	initiators = iscsi_parse_initiator(opts);
+
+#ifdef DEBUG
+	fprintf(stderr, "iscsi_enable_share_one_scst: name=%s, iomode=%s, "
+		"type=%s, lun=%d, blocksize=%d,  authname=%s, authpass=%s\n",
+		opts->name, opts->iomode, opts->type, opts->lun,
+		opts->blocksize, opts->authname, opts->authpass);
+#endif
+
+	/*
+	 * ======
+	 * PART 1 - Add target
+	 * CMD: echo "add_target IQN" > $SYSFS/targets/iscsi/mgmt
+	 */
+	ret = sprintf(path, "%s/targets/iscsi/mgmt", SYSFS_SCST);
+	if (ret < 0 || ret >= sizeof (buffer)) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+
+	ret = snprintf(buffer, sizeof (buffer), "add_target %s", opts->name);
+	if (ret < 0 || ret >= sizeof (buffer)) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+	if (iscsi_write_sysfs_value(path, buffer) != SA_OK) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+
+	/*
+	 * ======
+	 * PART 2 - Add device
+	 * CMD: echo "add_device DEV filename=/dev/zvol/$vol;blocksize=512" \
+	 *	> $SYSFS/handlers/vdisk_blockio/mgmt
+	 */
+	ret = snprintf(path, sizeof (buffer), "%s/handlers/vdisk_%s/mgmt",
+			SYSFS_SCST, opts->type);
+	if (ret < 0 || ret >= sizeof (path)) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+	ret = snprintf(buffer, sizeof (buffer), "add_device %s filename=%s; "
+			"blocksize=%d", device, impl_share->sharepath,
+			opts->blocksize);
+	if (ret < 0 || ret >= sizeof (buffer)) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+	if (iscsi_write_sysfs_value(path, buffer) != SA_OK) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+
+	if (!strlen(opts->authname) || list_is_empty(initiators)) {
+		/*
+		 * ======
+		 * PART 3 - Add lun
+		 * -> target based authentication
+		 * CMD: echo "add DEV 0" > $SYSFS/targets/iscsi/IQN/luns/mgmt
+		 */
+		ret = snprintf(path, sizeof (path),
+			"%s/targets/iscsi/%s/luns/mgmt",
+			SYSFS_SCST, opts->name);
+		if (ret < 0 || ret >= sizeof (path)) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+		ret = snprintf(buffer, sizeof (buffer), "add %s %d", device,
+			opts->lun);
+		if (ret < 0 || ret >= sizeof (buffer)) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+		if (iscsi_write_sysfs_value(path, buffer) != SA_OK) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+	}
+
+	/*
+	 * PART 4a - work in per-portal access control mode
+	 * CMD: echo 1 > $SYSFS/targets/iscsi/IQN/per_portal_acl
+	 */
+	ret = sprintf(path, "%s/targets/iscsi/%s/per_portal_acl",
+			SYSFS_SCST, opts->name);
+	if (ret < 0 || ret >= sizeof (buffer)) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+	strcpy(buffer, "1");
+	if (iscsi_write_sysfs_value(path, buffer) != SA_OK) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+
+	/* PART 4 - access control */
+
+	/*
+	 * PART 4b - set user+pass authentication
+	 * CMD: echo "add_target_attribute IQN IncomingUser USER PASS"	\
+	 *      > $SYSFS/targets/iscsi/mgmt
+	 */
+	ret = sprintf(path, "%s/targets/iscsi/mgmt", SYSFS_SCST);
+	if (ret < 0 || ret >= sizeof (buffer)) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+	ret = snprintf(buffer, sizeof (buffer),
+		"add_target_attribute %s IncomingUser %s %s",
+		opts->name, opts->authname, opts->authpass);
+	if (ret < 0 || ret >= sizeof (buffer)) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+	if (iscsi_write_sysfs_value(path, buffer) != SA_OK) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+
+	for (initiator = list_head(initiators);
+		initiator != NULL;
+		initiator = list_next(initiators, initiator)) {
+		/*
+		 * PART 4c - create security group
+		 * CMD: echo "create GROUP" \
+		 *      > $SYSFS/targets/iscsi/IQN/ini_groups/mgmt
+		 *
+		 * NOTE: We use the initiator name as group name.
+		 */
+		ret = snprintf(path, sizeof (path),
+			"%s/targets/iscsi/%s/ini_groups/mgmt",
+			SYSFS_SCST, opts->name);
+		if (ret < 0 || ret >= sizeof (path)) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+		ret = snprintf(buffer, sizeof (buffer), "create %s",
+			initiator->initiator);
+		if (ret < 0 || ret >= sizeof (buffer)) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+		if (iscsi_write_sysfs_value(path, buffer) != SA_OK) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+
+		/*
+		 * PART 4d - add lun to security group
+		 * -> initiator based authentication
+		 * CMD: echo "add DEV LUN read_only=[01]" \
+		 * > $SYSFS/targets/iscsi/IQN/ini_groups/GROUP/luns/mgmt
+		 */
+		ret = snprintf(path, sizeof (path),
+			"%s/targets/iscsi/%s/ini_groups/%s/luns/mgmt",
+			SYSFS_SCST, opts->name, initiator->initiator);
+		if (ret < 0 || ret >= sizeof (path)) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+		ret = snprintf(buffer, sizeof (buffer), "add %s %d "
+			"read_only=%d", device, opts->lun,
+			initiator->read_only);
+		if (ret < 0 || ret >= sizeof (buffer)) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+		if (iscsi_write_sysfs_value(path, buffer) != SA_OK) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+
+		/*
+		 * PART 4e - add initiator to security group
+		 * CMD: echo "add IQN" \
+		 * > $SYSFS/targets/iscsi/IQN/ini_groups/GRP/initiators/mgmt
+		 */
+		ret = snprintf(path, sizeof (path),
+			"%s/targets/iscsi/%s/ini_groups/%s/"
+			"initiators/mgmt", SYSFS_SCST, opts->name,
+			initiator->initiator);
+		if (ret < 0 || ret >= sizeof (path)) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+
+		ret = snprintf(buffer, sizeof (buffer), "add %s",
+			initiator->initiator);
+		if (ret < 0 || ret >= sizeof (buffer)) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+		if (iscsi_write_sysfs_value(path, buffer) != SA_OK) {
+			free(opts);
+			return (SA_NO_MEMORY);
+		}
+	}
+
+	/*
+	 * ======
+	 * PART 5 - Enable target
+	 * CMD: echo 1 > $SYSFS/targets/iscsi/$name/enabled
+	 */
+	ret = snprintf(path, sizeof (path), "%s/targets/iscsi/%s/enabled",
+			SYSFS_SCST, opts->name);
+	if (ret < 0 || ret >= sizeof (path)) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+	strcpy(buffer, "1");
+	if (iscsi_write_sysfs_value(path, buffer) != SA_OK) {
+		free(opts);
+		return (SA_NO_MEMORY);
+	}
+
+	/*
+	 * ======
+	 * PART 6 - Run local update script.
+	 */
+	if (access(EXTRA_ISCSI_SHARE_SCRIPT, X_OK) == 0) {
+		/* CMD: /sbin/zfs_share_iscsi <TID> */
+		argv[0] = (char *)EXTRA_ISCSI_SHARE_SCRIPT;
+		argv[1] = opts->name;
+		argv[2] = NULL;
+
+#ifdef DEBUG
+		int i;
+		fprintf(stderr, "CMD: ");
+		for (i = 0; i < 2; i++)
+			fprintf(stderr, "%s ", argv[i]);
+		fprintf(stderr, "\n");
+#endif
+
+		/* Ignore any error from script - "fire and forget" */
+		libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	}
+
+	free(opts);
+
+	return (SA_OK);
+}
+
+int
+iscsi_disable_share_one_scst(int tid)
+{
+	int ret;
+	char path[PATH_MAX], buffer[255];
+	iscsi_target_t *target;
+
+	for (target = list_head(&all_iscsi_targets_list);
+	    target != NULL;
+	    target = list_next(&all_iscsi_targets_list, target)) {
+		if (target->tid == tid) {
+#ifdef DEBUG
+			fprintf(stderr, "iscsi_disable_share_one_scst: "
+				"target=%s, tid=%d, path=%s, iotype=%s\n",
+				target->name, target->tid,
+				target->path, target->iotype);
+#endif
+
+			break;
+		}
+	}
+
+	/*
+	 * ======
+	 * PART 1 - Disable target
+	 * CMD: echo 0 > $SYSFS/targets/iscsi/$name/enabled
+	 */
+	ret = snprintf(path, sizeof (path), "%s/targets/iscsi/%s/enabled",
+			SYSFS_SCST, target->name);
+	if (ret < 0 || ret >= sizeof (path))
+		return (SA_SYSTEM_ERR);
+	strcpy(buffer, "0");
+	if (iscsi_write_sysfs_value(path, buffer) != SA_OK)
+		return (SA_NO_MEMORY);
+
+	/*
+	 * ======
+	 * PART 2 - Delete device
+	 *
+	 * dev=`/bin/ls -l \
+	 *  $SYSFS/targets/iscsi/$name/luns/0/device | sed 's@.*\/@@'`
+	 * echo "del_device $dev" > $SYSFS/handlers/vdisk_blockio/mgmt
+	 */
+	ret = snprintf(path, sizeof (path), "%s/handlers/vdisk_%s/mgmt",
+			SYSFS_SCST, target->iotype);
+	if (ret < 0 || ret >= sizeof (path))
+		return (SA_SYSTEM_ERR);
+	ret = snprintf(buffer, sizeof (buffer), "del_device %s",
+		    target->device);
+	if (ret < 0 || ret >= sizeof (buffer))
+		return (SA_SYSTEM_ERR);
+	if (iscsi_write_sysfs_value(path, buffer) != SA_OK)
+		return (SA_NO_MEMORY);
+
+	/*
+	 * ======
+	 * PART 3 - Delete target
+	 * CMD: echo "del_target $name" > $SYSFS/targets/iscsi/mgmt
+	 */
+	ret = snprintf(path, sizeof (path), "%s/targets/iscsi/mgmt",
+			SYSFS_SCST);
+	if (ret < 0 || ret >= sizeof (path))
+		return (SA_SYSTEM_ERR);
+	ret = snprintf(buffer, sizeof (buffer), "del_target %s",
+		    target->name);
+	if (ret < 0 || ret >= sizeof (buffer))
+		return (SA_SYSTEM_ERR);
+	if (iscsi_write_sysfs_value(path, buffer) != SA_OK)
+		return (SA_NO_MEMORY);
+
+	return (SA_OK);
+}
Index: pkg-zfs/lib/libshare/iscsi_stgt.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/iscsi_stgt.c	2016-05-10 22:53:08.727292769 +0000
@@ -0,0 +1,759 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright (c) 2011-2014 Turbo Fredriksson <turbo@bayour.com>
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stddef.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <libzfs.h>
+#include <libshare.h>
+#include <sys/fs/zfs.h>
+#include "libshare_impl.h"
+#include "iscsi.h"
+
+/*
+ * ============================================================
+ * Support functions
+ */
+
+char *
+trim(char *str)
+{
+	size_t len = 0;
+	char *frontp = str;
+	char *endp = NULL;
+
+	if (str == NULL)
+		return (NULL);
+	if (str[0] == '\0')
+		return (str);
+
+	len = strlen(str);
+	endp = str + len;
+
+	/*
+	 * Move the front and back pointers to address the first non-whitespace
+	 * characters from each end.
+	 */
+	while (isspace(*frontp))
+		++frontp;
+	if (endp != frontp)
+		while (isspace(*(--endp)) && endp != frontp) {}
+
+	if (str + len - 1 != endp)
+		*(endp + 1) = '\0';
+	else if (frontp != str && endp == frontp)
+		*str = '\0';
+
+	/*
+	 * Shift the string so that it starts at str so that if it's dynamically
+	 * allocated, we can still free it on the returned pointer. Note the
+	 * reuse of endp to mean the front of the string buffer now.
+	 */
+	endp = str;
+	if (frontp != str) {
+		while (*frontp)
+			*endp++ = *frontp++;
+		*endp = '\0';
+	}
+
+	return (str);
+}
+
+/*
+ * Can only retreive the sessions/connections for one TID,
+ * so this one accepts the parameter TID.
+ */
+static list_t *
+iscsi_retrieve_sessions_stgt(int tid)
+{
+	int rc = SA_OK, buffer_len;
+	char buffer[512], cmd[PATH_MAX];
+	char *token, *dup_value;
+	FILE *shareiscsi_temp_fp;
+	iscsi_session_t *session = NULL;
+	list_t *target_sessions = malloc(sizeof (list_t));
+
+	/* For storing the share info */
+	char *initiator = NULL, *address = NULL;
+
+	list_create(target_sessions, sizeof (iscsi_session_t),
+		    offsetof(iscsi_session_t, next));
+
+	/* CMD: tgtadm --lld iscsi --op show --mode conn --tid TID */
+	rc = snprintf(cmd, sizeof (cmd), "%s --lld iscsi --op show "
+		    "--mode conn --tid %d", STGT_CMD_PATH, tid);
+
+	if (rc < 0 || rc >= sizeof (cmd))
+		return (NULL);
+
+#ifdef DEBUG
+	fprintf(stderr, "CMD: %s\n", cmd);
+#endif
+
+	shareiscsi_temp_fp = popen(cmd, "r");
+	if (shareiscsi_temp_fp == NULL)
+		return (NULL);
+
+	while (fgets(buffer, sizeof (buffer), shareiscsi_temp_fp) != 0) {
+		/* Trim trailing new-line character(s). */
+		buffer_len = strlen(buffer);
+		while (buffer_len > 0) {
+			buffer_len--;
+			if (buffer[buffer_len] == '\r' ||
+			    buffer[buffer_len] == '\n') {
+				buffer[buffer_len] = 0;
+			} else
+				break;
+		}
+
+		token = strchr(buffer, ':');
+		dup_value = strdup(token + 2);
+
+		if (strncmp(buffer, "        Initiator: ", 19) == 0) {
+			initiator = dup_value;
+		} else if (strncmp(buffer, "        IP Address: ", 20) == 0) {
+			address = dup_value;
+		}
+
+		if (initiator == NULL || address == NULL)
+			continue; /* Incomplete session definition */
+
+		session = iscsi_session_list_alloc();
+		if (session == NULL)
+			exit(SA_NO_MEMORY);
+
+		strncpy(session->name, "", sizeof (session->name));
+		session->tid = tid;
+		strncpy(session->initiator, initiator,
+			sizeof (session->initiator));
+		strncpy(session->ip, address, sizeof (session->ip));
+		session->state = 1;
+
+#ifdef DEBUG
+		fprintf(stderr, "iscsi_retrieve_sessions: target=%s, tid=%d, "
+			"initiator=%s, ip=%s, state=%d\n",
+			session->name, session->tid, session->initiator,
+			session->ip, session->state);
+#endif
+
+		/* Append the sessions to the list of new sessions */
+		list_insert_tail(target_sessions, session);
+	}
+
+	if (pclose(shareiscsi_temp_fp) != 0)
+		fprintf(stderr, "Failed to pclose stream\n");
+
+	return (target_sessions);
+}
+
+/*
+ * Retreive user list
+ */
+static list_t *
+iscsi_retrieve_users_stgt(void)
+{
+	int rc = SA_OK;
+	char buffer[512], cmd[PATH_MAX];
+	FILE *shareiscsi_temp_fp;
+	iscsi_users_t *users = NULL;
+	list_t *user_list = malloc(sizeof (list_t));
+
+	/* For storing the user info */
+	char *username = NULL;
+
+	list_create(user_list, sizeof (iscsi_users_t),
+		    offsetof(iscsi_users_t, next));
+
+	/* CMD: tgtadm --lld iscsi --op show --mode account */
+	rc = snprintf(cmd, sizeof (cmd), "%s --lld iscsi --op show "
+		"--mode account", STGT_CMD_PATH);
+
+	if (rc < 0 || rc >= sizeof (cmd))
+		return (NULL);
+
+#ifdef DEBUG
+	fprintf(stderr, "CMD: %s\n", cmd);
+#endif
+
+	shareiscsi_temp_fp = popen(cmd, "r");
+	if (shareiscsi_temp_fp == NULL)
+		return (NULL);
+
+	while (fgets(buffer, sizeof (buffer), shareiscsi_temp_fp) != 0) {
+		if (strncmp(buffer, "Account list", 12) == 0)
+			continue;
+
+		username = trim(buffer);
+
+
+		users = (iscsi_users_t *) malloc(sizeof (iscsi_users_t));
+		if (users == NULL)
+			exit(SA_NO_MEMORY);
+
+		list_link_init(&users->next);
+
+		strncpy(users->username, username, sizeof (users->username));
+
+#ifdef DEBUG
+		fprintf(stderr, "iscsi_retrieve_users_stgt: user=%s\n",
+			users->username);
+#endif
+
+		/* Append the sessions to the list of new sessions */
+		list_insert_tail(user_list, users);
+	}
+
+	if (pclose(shareiscsi_temp_fp) != 0)
+		fprintf(stderr, "Failed to pclose stream\n");
+
+	return (user_list);
+}
+
+/*
+ * Create a global user
+ */
+int
+iscsi_create_user_stgt(const char *username, const char *passwd)
+{
+	int rc;
+	char *argv[12];
+
+	/*
+	 * CMD: tgtadm --lld iscsi --op new --mode account \
+	 *      --user user --password pass
+	 */
+	argv[0]  = STGT_CMD_PATH;
+	argv[1]  = (char *)"--lld";
+	argv[2]  = (char *)"iscsi";
+	argv[3]  = (char *)"--op";
+	argv[4]  = (char *)"new";
+	argv[5]  = (char *)"--mode";
+	argv[6]  = (char *)"account";
+	argv[7]  = (char *)"--user";
+	argv[8]  = (char *)username;
+	argv[9]  = (char *)"--password";
+	argv[10] = (char *)passwd;
+	argv[11] = NULL;
+
+#ifdef DEBUG
+	int i;
+	fprintf(stderr, "CMD: ");
+	for (i = 0; i < 11; i++)
+		fprintf(stderr, "%s ", argv[i]);
+	fprintf(stderr, "\n");
+#endif
+
+	rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	if (rc != 0)
+		return (SA_SYSTEM_ERR);
+	else
+		return (SA_OK);
+}
+
+/*
+ * ============================================================
+ * Core functions
+ */
+
+int
+iscsi_retrieve_targets_stgt(void)
+{
+	int rc = SA_OK, buffer_len;
+	char buffer[512], cmd[PATH_MAX];
+	char *value, *token, *key, *colon;
+	FILE *shareiscsi_temp_fp;
+	iscsi_session_t *session;
+	list_t *sessions;
+
+	/* For soring the targets */
+	char *tid = NULL, *name = NULL, *lun = NULL, *state = NULL;
+	char *iotype = NULL, *iomode = NULL, *blocks = NULL;
+	char *blocksize = NULL, *path = NULL;
+	iscsi_target_t *target;
+
+	/* CMD: tgtadm --lld iscsi --op show --mode target */
+	rc = snprintf(cmd, sizeof (cmd), "%s --lld iscsi --op show "
+		    "--mode target", STGT_CMD_PATH);
+
+	if (rc < 0 || rc >= sizeof (cmd))
+		return (SA_SYSTEM_ERR);
+
+#ifdef DEBUG
+	fprintf(stderr, "CMD: %s\n", cmd);
+#endif
+
+	shareiscsi_temp_fp = popen(cmd, "r");
+	if (shareiscsi_temp_fp == NULL)
+		return (SA_SYSTEM_ERR);
+
+	while (fgets(buffer, sizeof (buffer), shareiscsi_temp_fp) != 0) {
+		/* Trim trailing new-line character(s). */
+		buffer_len = strlen(buffer);
+		while (buffer_len > 0) {
+			buffer_len--;
+			if (buffer[buffer_len] == '\r' ||
+			    buffer[buffer_len] == '\n') {
+				buffer[buffer_len] = 0;
+			} else
+				break;
+		}
+
+		if (strncmp(buffer, "Target ", 7) == 0) {
+			/* Target definition */
+			/* => Target 1: iqn.2012-11.com.bayour:test */
+
+			/* Split the line in three, separated by space */
+			token = strchr(buffer, ' ');
+			while (token != NULL) {
+				colon = strchr(token, ':');
+
+				if (colon == NULL)
+					goto next_token;
+
+				key = token + 1;
+				value = colon + 2;
+				*colon = '\0';
+
+				tid = strdup(key);
+				if (tid == NULL)
+					exit(SA_NO_MEMORY);
+
+				name = strdup(value);
+				if (name == NULL)
+					exit(SA_NO_MEMORY);
+next_token:
+				token = strtok(NULL, " ");
+			}
+		} else if (strncmp(buffer, "        LUN: ", 13) == 0) {
+			/* LUN */
+			token = strchr(buffer, ':');
+			lun = strdup(token + 2);
+		} else if (strncmp(buffer, "            Online: ",
+			    20) == 0) {
+			/* STATUS */
+			token = strchr(buffer, ':');
+			state = strdup(token + 2);
+		} else if (strncmp(buffer, "            Backing store path: ",
+			    32) == 0) {
+			/* PATH */
+			token = strchr(buffer, ':');
+			path = strdup(token + 2);
+
+			if (strncmp(path, "None", 4) == 0) {
+				/*
+				 * For some reason it isn't possible to
+				 * add a path to the first LUN, so it's
+				 * done in the second...
+				 * Reset the variables and try again in
+				 * the next loop round.
+				 */
+				lun = NULL;
+				path = NULL;
+			}
+		}
+
+		if (tid == NULL || name == NULL || lun == NULL ||
+		    state == NULL || path == NULL)
+			continue; /* Incomplete target definition */
+
+		target = (iscsi_target_t *) malloc(sizeof (iscsi_target_t));
+		if (target == NULL) {
+			rc = SA_NO_MEMORY;
+			goto retrieve_targets_stgt_out;
+		}
+
+		/* Save the values in the struct */
+		target->tid = atoi(tid);
+		target->lun = atoi(lun);
+		if (strncmp(state, "Yes", 3))
+			target->state = 1;
+		else
+			target->state = 0;
+		strncpy(target->name, name, sizeof (target->name));
+		strncpy(target->path, path, sizeof (target->path));
+
+		/* Get all sessions for this TID */
+		sessions = iscsi_retrieve_sessions_stgt(target->tid);
+
+		/* Link the session here */
+		target->session = NULL;
+		for (session = list_head(sessions);
+		    session != NULL;
+		    session = list_next(sessions, session)) {
+			if (session->tid == target->tid) {
+				target->session = session;
+				list_link_init(&target->session->next);
+
+				break;
+			}
+		}
+
+#ifdef DEBUG
+		fprintf(stderr, "iscsi_retrieve_targets_stgt: "
+			"target=%s, tid=%d, lun=%d, path=%s, active=%d\n",
+			target->name, target->tid, target->lun, target->path,
+			target->session ? target->session->state : -1);
+#endif
+
+		/* Append the target to the list of new targets */
+		list_insert_tail(&all_iscsi_targets_list, target);
+
+		tid = name = NULL;
+		lun = state = iotype = iomode = NULL;
+		blocks = blocksize = path = NULL;
+	}
+
+retrieve_targets_stgt_out:
+	if (pclose(shareiscsi_temp_fp) != 0)
+		fprintf(stderr, "Failed to pclose stream\n");
+
+	free(tid);
+	free(name);
+	free(lun);
+	free(state);
+	free(iotype);
+	free(iomode);
+	free(blocks);
+	free(blocksize);
+	free(path);
+
+	return (rc);
+}
+
+int
+iscsi_enable_share_one_stgt(sa_share_impl_t impl_share, int tid)
+{
+	int rc = SA_OK, ret, user_exists = 0;
+	char *argv[18], tid_s[11], vendid[22], iqn[255], *shareopts;
+	iscsi_shareopts_t *opts;
+	iscsi_users_t *usr;
+	list_t *users;
+	iscsi_initiator_list_t *initiator;
+	list_t *initiators;
+#ifdef DEBUG
+	int i;
+#endif
+
+#ifdef DEBUG
+	fprintf(stderr, "iscsi_enable_share_one_stgt: tid=%d, sharepath=%s\n",
+		tid, impl_share->sharepath);
+#endif
+
+	opts = (iscsi_shareopts_t *) malloc(sizeof (iscsi_shareopts_t));
+	if (opts == NULL)
+		return (SA_NO_MEMORY);
+
+	/* Get any share options */
+	shareopts = FSINFO(impl_share, iscsi_fstype)->shareopts;
+	rc = iscsi_get_shareopts(impl_share, shareopts, &opts);
+	if (rc < 0) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/* Parse 'initiator=...' option */
+	initiators = iscsi_parse_initiator(opts);
+
+	if (strlen(opts->authname) && strlen(opts->authpass)) {
+		/* Get users list */
+		users = iscsi_retrieve_users_stgt();
+
+		/* Make sure user exists */
+		for (usr = list_head(users);
+		    usr != NULL;
+		    usr = list_next(users, usr)) {
+			if (strcmp(usr->username, opts->authname) == 0) {
+				user_exists = 1;
+				break;
+			}
+		}
+
+		if (!user_exists) {
+			if ((rc = iscsi_create_user_stgt(opts->authname,
+				opts->authpass)) != SA_OK)
+				return (SA_SYSTEM_ERR);
+		}
+	}
+
+	/* int: between -2,147,483,648 and 2,147,483,647 => 10 chars + NUL */
+	ret = snprintf(tid_s, sizeof (tid_s), "%d", tid);
+	if (ret < 0 || ret >= sizeof (tid_s)) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/* Setup the vendor id value */
+	ret = snprintf(vendid, sizeof (vendid), "vendor_id=ZFSOnLinux");
+	if (ret < 0 || ret >= sizeof (vendid)) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+	vendid[21] = '\0';
+
+	/* Generate an IQN */
+	if (!opts->name) {
+		if (iscsi_generate_target(impl_share->dataset, iqn,
+					    sizeof (iqn)) != SA_OK)
+			return (SA_SYSTEM_ERR);
+	} else
+		strcpy(iqn, opts->name);
+
+	/* TODO: set 'iomode' and 'blocksize' */
+
+	/*
+	 * ------
+	 * PART 1 - do the (initial) share. No path etc...
+	 * CMD: tgtadm --lld iscsi --op new --mode target --tid TID	\
+	 *        --targetname `cat /etc/iscsi_target_id`:test
+	 */
+	argv[0]  = STGT_CMD_PATH;
+	argv[1]  = (char *)"--lld";
+	argv[2]  = (char *)"iscsi";
+	argv[3]  = (char *)"--op";
+	argv[4]  = (char *)"new";
+	argv[5]  = (char *)"--mode";
+	argv[6]  = (char *)"target";
+	argv[7]  = (char *)"--tid";
+	argv[8]  = tid_s;
+	argv[9]  = (char *)"--targetname";
+	argv[10] = iqn;
+	argv[11] = NULL;
+
+#ifdef DEBUG
+	fprintf(stderr, "CMD: ");
+	for (i = 0; i < 11; i++)
+		fprintf(stderr, "%s ", argv[i]);
+	fprintf(stderr, "\n");
+#endif
+
+	rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	if (rc != 0) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/*
+	 * ======
+	 * PART 2 - Set share path and lun.
+	 * CMD: tgtadm --lld iscsi --op new --mode logicalunit --tid 1 \
+	 *      --lun 1 --backing-store /dev/zvol/mypool/tests/iscsi/tst001
+	 *      --device-type disk --bstype rdwr
+	 */
+	argv[6]  = (char *)"logicalunit";
+	argv[7]  = (char *)"--tid";
+	argv[8]  = tid_s;
+	argv[9]  = (char *)"--lun";
+	argv[10] = (char *)"1";
+	argv[11] = (char *)"--backing-store";
+	argv[12] = impl_share->sharepath;
+	argv[13] = (char *)"--device-type";
+	argv[14] = opts->type;
+	argv[15] = (char *)"--bstype";
+	argv[16] = opts->iomode;
+	argv[17] = NULL;
+
+#ifdef DEBUG
+	fprintf(stderr, "CMD: ");
+	for (i = 0; i < 17; i++)
+		fprintf(stderr, "%s ", argv[i]);
+	fprintf(stderr, "\n");
+#endif
+
+	rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	if (rc != 0) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/*
+	 * ======
+	 * PART 3 - Bind the target to initiator(s)
+	 */
+	if (!list_is_empty(initiators)) {
+		for (initiator = list_head(initiators);
+			initiator != NULL;
+			initiator = list_next(initiators, initiator)) {
+			/*
+			 * CMD: tgtadm --lld iscsi --op bind --mode target \
+			 *      --tid 1 --initiator-address <initiator>
+			 */
+			argv[4]  = (char *)"bind";
+			argv[6]  = (char *)"target";
+			argv[9]  = (char *)"--initiator-address";
+			argv[10] = initiator->initiator;
+			argv[11] = NULL;
+
+#ifdef DEBUG
+			fprintf(stderr, "CMD: ");
+			for (i = 0; i < 11; i++)
+				fprintf(stderr, "%s ", argv[i]);
+			fprintf(stderr, "\n");
+#endif
+
+			rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+			if (rc != 0) {
+				free(opts);
+				return (SA_SYSTEM_ERR);
+			}
+		}
+	} else {
+		/*
+		 * CMD: tgtadm --lld iscsi --op bind --mode target --tid 1 \
+		 *      --initiator-address ALL
+		 */
+		argv[4]  = (char *)"bind";
+		argv[6]  = (char *)"target";
+		argv[9]  = (char *)"--initiator-address";
+		argv[10] = (char *)"ALL";
+		argv[11] = NULL;
+
+#ifdef DEBUG
+		fprintf(stderr, "CMD: ");
+		for (i = 0; i < 11; i++)
+			fprintf(stderr, "%s ", argv[i]);
+		fprintf(stderr, "\n");
+#endif
+
+		rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+		if (rc != 0) {
+			free(opts);
+			return (SA_SYSTEM_ERR);
+		}
+	}
+
+	/*
+	 * ======
+	 * PART 4 - Add user acl
+	 * CMD: tgtadm --lld iscsi --op bind --mode account --tid 1 \
+	 *      --user user
+	 */
+	if (strlen(opts->authname) && strlen(opts->authpass)) {
+		argv[4]  = (char *)"bind";
+		argv[6]  = (char *)"account";
+		argv[9]  = (char *)"--user";
+		argv[10] = opts->authname;
+		argv[11] = NULL;
+
+#ifdef DEBUG
+		fprintf(stderr, "CMD: ");
+		for (i = 0; i < 11; i++)
+			fprintf(stderr, "%s ", argv[i]);
+		fprintf(stderr, "\n");
+#endif
+
+		rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+		if (rc != 0) {
+			free(opts);
+			return (SA_SYSTEM_ERR);
+		}
+	}
+
+	/*
+	 * ======
+	 * PART 5 - Set vendor id = ZoL
+	 * CMD: tgtadm --lld iscsi --op update --mode logicalunit --tid 1 \
+	 *      --lun 1 --params vendor_id=ZFSOnLinux
+	 */
+	argv[4]  = (char *)"update";
+	argv[6]  = (char *)"logicalunit";
+	argv[9]  = (char *)"--lun";
+	argv[10] = (char *)"1";
+	argv[11] = (char *)"--params";
+	argv[12] = vendid;
+	argv[13] = NULL;
+
+#ifdef DEBUG
+	fprintf(stderr, "CMD: ");
+	for (i = 0; i < 13; i++)
+		fprintf(stderr, "%s ", argv[i]);
+	fprintf(stderr, "\n");
+#endif
+
+	rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	if (rc != 0) {
+		free(opts);
+		return (SA_SYSTEM_ERR);
+	}
+
+	/*
+	 * ======
+	 * PART 6 - Run local update script.
+	 */
+	if (access(EXTRA_ISCSI_SHARE_SCRIPT, X_OK) == 0) {
+		/* CMD: /sbin/zfs_share_iscsi <TID> */
+		argv[0] = (char *)EXTRA_ISCSI_SHARE_SCRIPT;
+		argv[1] = tid_s;
+		argv[2] = NULL;
+
+#ifdef DEBUG
+		fprintf(stderr, "CMD: ");
+		for (i = 0; i < 2; i++)
+			fprintf(stderr, "%s ", argv[i]);
+		fprintf(stderr, "\n");
+#endif
+
+		/* Ignore any error from script - "fire and forget" */
+		libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	}
+
+	return (SA_OK);
+}
+
+int
+iscsi_disable_share_one_stgt(int tid)
+{
+	int rc = SA_OK, ret;
+	char *argv[10], tid_s[11];
+
+	/* int: between -2,147,483,648 and 2,147,483,647 => 10 chars + NUL */
+	ret = snprintf(tid_s, sizeof (tid_s), "%d", tid);
+	if (ret < 0 || ret >= sizeof (tid_s))
+		return (SA_SYSTEM_ERR);
+
+	/* CMD: tgtadm --lld iscsi --op delete --mode target --tid TID */
+	argv[0] = STGT_CMD_PATH;
+	argv[1] = (char *)"--lld";
+	argv[2] = (char *)"iscsi";
+	argv[3] = (char *)"--op";
+	argv[4] = (char *)"delete";
+	argv[5] = (char *)"--mode";
+	argv[6] = (char *)"target";
+	argv[7] = (char *)"--tid";
+	argv[8] = tid_s;
+	argv[9] = NULL;
+
+#ifdef DEBUG
+	int i;
+	fprintf(stderr, "CMD: ");
+	for (i = 0; i < 9; i++)
+		fprintf(stderr, "%s ", argv[i]);
+	fprintf(stderr, "\n");
+#endif
+
+	rc = libzfs_run_process(argv[0], argv, STDERR_VERBOSE);
+	if (rc != 0)
+		return (SA_SYSTEM_ERR);
+	else
+		return (SA_OK);
+}
Index: pkg-zfs/lib/libshare/libshare.c
===================================================================
--- pkg-zfs.orig/lib/libshare/libshare.c	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/lib/libshare/libshare.c	2016-05-10 22:53:08.739292618 +0000
@@ -37,6 +37,7 @@
 #include "libshare_impl.h"
 #include "nfs.h"
 #include "smb.h"
+#include "iscsi.h"
 
 static sa_share_impl_t find_share(sa_handle_impl_t handle,
     const char *sharepath);
@@ -56,6 +57,66 @@
 static int fstypes_count;
 static sa_fstype_t *fstypes;
 
+/*
+ * Invokes the specified callback function for each Solaris share option
+ * listed in the specified string.
+ */
+int
+foreach_shareopt(const char *shareopts,
+    shareopt_callback_t callback, void *cookie)
+{
+	char *shareopts_dup, *opt, *cur, *value;
+	int was_nul, rc;
+
+	if (shareopts == NULL)
+		return (SA_OK);
+
+	shareopts_dup = strdup(shareopts);
+
+	if (shareopts_dup == NULL)
+		return (SA_NO_MEMORY);
+
+	opt = shareopts_dup;
+	was_nul = 0;
+
+	while (1) {
+		cur = opt;
+
+		while (*cur != ',' && *cur != '\0')
+			cur++;
+
+		if (*cur == '\0')
+			was_nul = 1;
+
+		*cur = '\0';
+
+		if (cur > opt) {
+			value = strchr(opt, '=');
+
+			if (value != NULL) {
+				*value = '\0';
+				value++;
+			}
+
+			rc = callback(opt, value, cookie);
+
+			if (rc != SA_OK) {
+				free(shareopts_dup);
+				return (rc);
+			}
+		}
+
+		opt = cur + 1;
+
+		if (was_nul)
+			break;
+	}
+
+	free(shareopts_dup);
+
+	return (0);
+}
+
 sa_fstype_t *
 register_fstype(const char *name, const sa_share_ops_t *ops)
 {
@@ -105,6 +166,7 @@
 {
 	libshare_nfs_init();
 	libshare_smb_init();
+	libshare_iscsi_init();
 }
 
 static void
@@ -238,13 +300,14 @@
 		return (1);
 	}
 
-	if (type != ZFS_TYPE_FILESYSTEM) {
+	if (type != ZFS_TYPE_FILESYSTEM && type != ZFS_TYPE_VOLUME) {
 		zfs_close(zhp);
 		return (0);
 	}
 
-	if (zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT, mountpoint,
-	    sizeof (mountpoint), NULL, NULL, 0, B_FALSE) != 0) {
+	if (type == ZFS_TYPE_FILESYSTEM && zfs_prop_get(zhp,
+	    ZFS_PROP_MOUNTPOINT, mountpoint, sizeof (mountpoint), NULL, NULL,
+	    0, B_FALSE) != 0) {
 		zfs_close(zhp);
 		return (0);
 	}
@@ -256,7 +319,16 @@
 		return (0);
 	}
 
-	if (!zfs_is_mounted(zhp, NULL)) {
+	if (type == ZFS_TYPE_VOLUME) {
+		/* TODO: check whether this is sane */
+		if (sprintf(mountpoint, "%s/%s/%s", ZVOL_DIR, ZVOL_DRIVER,
+			    dataset) < 0) {
+			zfs_close(zhp);
+			return (0);
+		}
+	}
+
+	if (type == ZFS_TYPE_FILESYSTEM && !zfs_is_mounted(zhp, NULL)) {
 		zfs_close(zhp);
 		return (0);
 	}
@@ -277,6 +349,14 @@
 		    "smb", shareopts, NULL, dataset, B_FALSE);
 	}
 
+	if ((udata->proto == NULL || strcmp(udata->proto, "iscsi") == 0) &&
+	    zfs_prop_get(zhp, ZFS_PROP_SHAREISCSI, shareopts,
+	    sizeof (shareopts), NULL, NULL, 0, B_FALSE) == 0 &&
+	    strcmp(shareopts, "off") != 0) {
+		(void) process_share(udata->handle, NULL, mountpoint, NULL,
+		    "iscsi", shareopts, NULL, dataset, B_FALSE);
+	}
+
 	zfs_close(zhp);
 
 	return (0);
@@ -295,7 +375,7 @@
 	assert(impl_share->dataset != NULL);
 
 	zhp = zfs_open(impl_share->handle->zfs_libhandle, impl_share->dataset,
-	    ZFS_TYPE_FILESYSTEM);
+	    ZFS_TYPE_FILESYSTEM|ZFS_TYPE_VOLUME);
 
 	if (zhp == NULL)
 		return (SA_SYSTEM_ERR);
@@ -337,14 +417,24 @@
 
 	new_share = B_FALSE;
 
-	if (impl_share == NULL)
+	if (impl_share == NULL && strlen(pathname))
 		impl_share = find_share(impl_handle, pathname);
 
 	if (impl_share == NULL) {
-		if (lstat(pathname, &statbuf) != 0 ||
-		    !S_ISDIR(statbuf.st_mode))
+		if (lstat(pathname, &statbuf) != 0)
+			return (SA_BAD_PATH);
+
+		if (!S_ISDIR(statbuf.st_mode) && !S_ISLNK(statbuf.st_mode))
 			return (SA_BAD_PATH);
 
+		if (S_ISLNK(statbuf.st_mode)) {
+			if (stat(pathname, &statbuf) != 0)
+				return (SA_BAD_PATH);
+
+			if (!S_ISBLK(statbuf.st_mode))
+				return (SA_BAD_PATH);
+		}
+
 		impl_share = alloc_share(pathname);
 
 		if (impl_share == NULL) {
@@ -404,7 +494,6 @@
 
 		impl_share->next = impl_handle->shares;
 		impl_handle->shares = impl_share;
-
 	}
 
 err:
@@ -472,9 +561,8 @@
 
 	impl_share = impl_handle->shares;
 	while (impl_share != NULL) {
-		if (strcmp(impl_share->sharepath, sharepath) == 0) {
+		if (strcmp(impl_share->sharepath, sharepath) == 0)
 			break;
-		}
 
 		impl_share = impl_share->next;
 	}
Index: pkg-zfs/lib/libshare/libshare_impl.h
===================================================================
--- pkg-zfs.orig/lib/libshare/libshare_impl.h	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/lib/libshare/libshare_impl.h	2016-05-10 22:53:08.739292618 +0000
@@ -67,4 +67,10 @@
 	sa_share_impl_t shares;
 } *sa_handle_impl_t;
 
-sa_fstype_t *register_fstype(const char *name, const sa_share_ops_t *ops);
+typedef int (*shareopt_callback_t)(const char *opt, const char *value,
+    void *cookie);
+
+sa_fstype_t *register_fstype(const char *name,
+			const sa_share_ops_t *ops);
+int foreach_shareopt(const char *shareopts,
+		shareopt_callback_t callback, void *cookie);
Index: pkg-zfs/lib/libshare/list_iet.sh
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/list_iet.sh	2016-05-10 22:53:08.743292568 +0000
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+cat /proc/net/iet/volume
Index: pkg-zfs/lib/libshare/list_lio.sh
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/list_lio.sh	2016-05-10 22:53:08.743292568 +0000
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+echo "/ ls" | targetcli
Index: pkg-zfs/lib/libshare/list_scst.sh
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/list_scst.sh	2016-05-10 22:53:08.743292568 +0000
@@ -0,0 +1,55 @@
+#!/bin/sh
+
+SYSFS=/sys/kernel/scst_tgt
+
+#for cmd in handler device target driver; do
+#    echo $cmd"s: "
+#    scstadmin -list_$cmd | egrep -v '^Collecting|^All done.|^$|-----|Handler|Driver'
+#    echo
+#done
+
+echo -n "Drivers:  "
+DRIVERS=`find $SYSFS/targets/* -maxdepth 0 2> /dev/null | sed "s@.*/@@"`
+for driver in $DRIVERS; do
+    echo -n "$driver "
+done
+echo
+
+echo -n "Handlers: "
+HANDLERS=`find $SYSFS/handlers/*/type 2> /dev/null`
+for file in $HANDLERS; do
+    handler=`echo "$file" | sed "s@.*handlers/\(.*\)/.*@\1@"`
+    echo -n "$handler "
+done
+echo
+
+echo "Devices:"
+DEVICES=`find $SYSFS/devices/*/filename 2> /dev/null`
+for file in $DEVICES; do
+    device=`echo "$file" | sed "s@.*devices/\(.*\)/.*@\1@"`
+    fsdev=`cat "$file" | head -n1`
+    handler=`/bin/ls -l $SYSFS/devices/$device/handler  | sed "s@.*handlers/\(.*\)@\1@"`
+    blocksize=`head -n1 $SYSFS/devices/$device/blocksize`
+    size_mb=`cat $SYSFS/devices/$device/size_mb`
+
+    printf "  %-16s %-16s %-50s %5sB %sMB\n" "$handler" "$device" "$fsdev" "$blocksize" "$size_mb"
+done
+
+echo "Targets:"
+for driver in $DRIVERS; do
+    TARGETS=`find $SYSFS/targets/$driver/iqn*/enabled 2> /dev/null`
+    for file in $TARGETS; do
+	dir=`dirname "$file"`
+	iqn=`echo "$file" | sed "s@.*/iscsi/\(.*\)/.*@\1@"`
+	stat=`cat $file`
+	if [ "$stat" -eq "1" ]; then
+	    tid=`cat $dir/tid`
+	    lun=""
+	    if [ -d "$SYSFS/targets/$driver/$iqn/luns/0" ]; then
+		device=`/bin/ls -l $SYSFS/targets/$driver/$iqn/luns/0/device | sed 's@.*/@@'`
+	    fi
+	    printf "  %4s  %-7s    %-68s %s\n" "$tid" "$driver" "$iqn" "$device"
+	fi
+    done
+done
+
Index: pkg-zfs/lib/libshare/list_stgt.sh
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/list_stgt.sh	2016-05-10 22:53:08.747292518 +0000
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+tgtadm --lld iscsi --op show --mode target
Index: pkg-zfs/lib/libshare/nfs.c
===================================================================
--- pkg-zfs.orig/lib/libshare/nfs.c	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/lib/libshare/nfs.c	2016-05-10 22:53:08.747292518 +0000
@@ -44,72 +44,9 @@
  */
 static int nfs_exportfs_temp_fd = -1;
 
-typedef int (*nfs_shareopt_callback_t)(const char *opt, const char *value,
-    void *cookie);
-
 typedef int (*nfs_host_callback_t)(const char *sharepath, const char *host,
     const char *security, const char *access, void *cookie);
 
-/*
- * Invokes the specified callback function for each Solaris share option
- * listed in the specified string.
- */
-static int
-foreach_nfs_shareopt(const char *shareopts,
-    nfs_shareopt_callback_t callback, void *cookie)
-{
-	char *shareopts_dup, *opt, *cur, *value;
-	int was_nul, rc;
-
-	if (shareopts == NULL)
-		return (SA_OK);
-
-	shareopts_dup = strdup(shareopts);
-
-	if (shareopts_dup == NULL)
-		return (SA_NO_MEMORY);
-
-	opt = shareopts_dup;
-	was_nul = 0;
-
-	while (1) {
-		cur = opt;
-
-		while (*cur != ',' && *cur != '\0')
-			cur++;
-
-		if (*cur == '\0')
-			was_nul = 1;
-
-		*cur = '\0';
-
-		if (cur > opt) {
-			value = strchr(opt, '=');
-
-			if (value != NULL) {
-				*value = '\0';
-				value++;
-			}
-
-			rc = callback(opt, value, cookie);
-
-			if (rc != SA_OK) {
-				free(shareopts_dup);
-				return (rc);
-			}
-		}
-
-		opt = cur + 1;
-
-		if (was_nul)
-			break;
-	}
-
-	free(shareopts_dup);
-
-	return (0);
-}
-
 typedef struct nfs_host_cookie_s {
 	nfs_host_callback_t callback;
 	const char *sharepath;
@@ -192,7 +129,7 @@
 
 	shareopts = FSINFO(impl_share, nfs_fstype)->shareopts;
 
-	return foreach_nfs_shareopt(shareopts, foreach_nfs_host_cb,
+	return foreach_shareopt(shareopts, foreach_nfs_host_cb,
 	    &udata);
 }
 
@@ -390,8 +327,7 @@
 	(void) add_linux_shareopt(plinux_opts, "no_root_squash", NULL);
 	(void) add_linux_shareopt(plinux_opts, "mountpoint", NULL);
 
-	rc = foreach_nfs_shareopt(shareopts, get_linux_shareopts_cb,
-	    plinux_opts);
+	rc = foreach_shareopt(shareopts, get_linux_shareopts_cb, plinux_opts);
 
 	if (rc != SA_OK) {
 		free(*plinux_opts);
Index: pkg-zfs/lib/libshare/zfs_share_iscsi.iet
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/zfs_share_iscsi.iet	2016-05-10 22:53:08.751292468 +0000
@@ -0,0 +1,44 @@
+#!/bin/sh
+
+# !! This script is for iSCSI-IET !!
+
+if ! type ietadm > /dev/null 2>&1; then
+    exit 1
+fi
+
+tid=$1
+
+# Only edit AFTER the '-----' line !
+
+if [ -z "$1" ]; then
+    echo "Usage: `basename $0` [tid]"
+    exit 1
+fi
+
+target_mod() {
+    param=$1
+    value=$2
+
+    ietadm --op update --tid $tid --params \
+	$param=$value
+}
+
+# ----------------------------------------------
+
+# Only edit this after this point.
+
+target_mod InitialR2T	No
+target_mod ImmediateData Yes
+
+target_mod MaxRecvDataSegmentLength 262144
+target_mod MaxXmitDataSegmentLength 65536
+
+target_mod MaxBurstLength 131072
+target_mod FirstBurstLength 32768
+target_mod MaxOutstandingR2T 1
+
+target_mod HeaderDigest "CRC32C,None"
+target_mod DataDigest "CRC32C,None"
+target_mod QueuedCommands 32
+
+exit 0
Index: pkg-zfs/lib/libshare/zfs_share_iscsi.lio
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/zfs_share_iscsi.lio	2016-05-10 22:53:08.751292468 +0000
@@ -0,0 +1,118 @@
+#!/bin/bash
+
+# !! This script is for ISCSI-SCST !!
+
+SYSFS=/sys/kernel/config/target
+
+if [ ! -d $SYSFS ]; then
+    exit 1
+fi
+
+# Only edit AFTER the '-----' line !
+
+if [ -z "$1" ]; then
+    echo "Usage: `basename $0` [IQN:identifier]"
+    exit 1
+fi
+
+find_iqn() {
+    tid=$1
+
+    find $SYSFS/iscsi/iqn.*/tpgt_$tid -maxdepth 0 -type d
+}
+
+find_iblock() {
+    tid=$1
+
+    find $SYSFS/core/{iblock,fileio}_$tid/iqn.* -maxdepth 0 -type d \
+	2> /dev/null
+}
+
+
+# lio_mod <parameter> <value>
+lio_mod() {
+    param=$1
+    value=$2
+
+    dir=$LIO_DIR/param/$param
+
+    if [ -f "$dir" ]; then
+	echo "$value" > $dir
+    else
+	echo "No such dir/param ($dir)"
+    fi
+}
+
+# tcm_mod <parameter> <value>
+tcm_mod() {
+    param=$1
+    value=$2
+
+    dir=$TCM_DIR/attrib/$param
+
+    if [ -f "$dir" ]; then
+	echo "$value" > $dir
+    else
+	echo "No such dir/param ($dir)"
+    fi
+}
+
+LIO_DIR=$(find_iqn $1)
+TCM_DIR=$(find_iblock $1)
+
+# ----------------------------------------------
+
+# Only edit this after this point.
+
+lio_mod InitialR2T			Yes
+lio_mod ImmediateData			Yes
+
+lio_mod MaxRecvDataSegmentLength	262144
+lio_mod MaxXmitDataSegmentLength	65536
+
+lio_mod MaxBurstLength			1048512
+lio_mod FirstBurstLength		262144
+lio_mod MaxOutstandingR2T		30
+lio_mod QueuedCommands			32
+
+lio_mod HeaderDigest			"None"
+lio_mod DataDigest			"None"
+lio_mod AuthMethod			"None"
+
+lio_mod MaxConnections			10
+
+lio_mod prod_mode_write_protect		0
+lio_mod demo_mode_write_protect		0
+lio_mod cache_dynamic_acls		1
+lio_mod default_cmdsn_depth		16
+lio_mod generate_node_acls		1
+lio_mod netif_timeout			2
+lio_mod login_timeout			15
+
+lio_mod OFMarkInt			"2048~65535"
+lio_mod IFMarkInt			"2048~65535"
+lio_mod OFMarker			No
+lio_mod IFMarker			No
+lio_mod ErrorRecoveryLevel		0
+lio_mod DataSequenceInOrder		Yes
+lio_mod DataPDUInOrder			Yes
+lio_mod DefaultTime2Retain		20
+lio_mod DefaultTime2Wait		2
+lio_mod TargetAlias			"LIO Target"
+
+
+#tcm_mod queue_depth			128
+
+tcm_mod emulate_3pc			1
+tcm_mod emulate_caw			1
+tcm_mod emulate_tpws			0
+tcm_mod emulate_tpu			1
+#tcm_mod emulate_tas			1
+#tcm_mod emulate_ua_intlck_ctrl		0
+tcm_mod emulate_write_cache		0
+tcm_mod emulate_fua_read		0
+tcm_mod emulate_fua_write		1
+tcm_mod emulate_dpo			0
+#tcm_mod emulate_model_alias		0
+
+exit 0
Index: pkg-zfs/lib/libshare/zfs_share_iscsi.scst
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/zfs_share_iscsi.scst	2016-05-10 22:53:08.755292417 +0000
@@ -0,0 +1,61 @@
+#!/bin/sh
+
+# !! This script is for ISCSI-SCST !!
+
+SYSFS=/sys/kernel/scst_tgt
+
+if [ ! -d $SYSFS ]; then
+    exit 1
+fi
+
+# Read 'iscsi-scst/README' in the SCST source directory
+# for more information.
+
+# Only edit AFTER the '-----' line !
+
+if [ -z "$1" ]; then
+    echo "Usage: `basename $0` [IQN:identifier]"
+    exit 1
+fi
+
+target_mod() {
+    param=$1
+    value=$2
+
+    dir=$SYSFS/targets/iscsi/$name
+
+    echo "$value" > $dir/$param
+}
+
+iscsi_mgmt() {
+    opts="$*"
+
+    echo "add_target_attribute $opts" > $SYSFS/targets/iscsi/mgmt
+}
+
+name=$1
+
+# ----------------------------------------------
+
+# Only edit this after this point.
+
+#iscsi_mgmt $name IncomingUser1 joe2 12charsecret2
+#iscsi_mgmt $name IncomingUser  joe  12charsecret
+#iscsi_mgmt $name OutgoingUser  jim1 12charpasswd
+#iscsi_mgmt $name allowed_portal 10.170.77.2
+
+target_mod InitialR2T			Yes
+target_mod ImmediateData		Yes
+
+target_mod MaxRecvDataSegmentLength	262144
+target_mod MaxXmitDataSegmentLength	65536
+
+target_mod MaxBurstLength		1048512
+target_mod FirstBurstLength		262144
+target_mod MaxOutstandingR2T		30
+target_mod QueuedCommands		32
+
+target_mod HeaderDigest			None
+target_mod DataDigest			None
+
+exit 0
Index: pkg-zfs/lib/libshare/zfs_share_iscsi.stgt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/lib/libshare/zfs_share_iscsi.stgt	2016-05-10 22:53:08.755292417 +0000
@@ -0,0 +1,71 @@
+#!/bin/sh
+
+# !! This script is for iSCSI-STGT !!
+
+if ! type tgtadm > /dev/null 2>&1; then
+    exit 1
+fi
+
+tid=$1
+
+# Only edit AFTER the '-----' line !
+
+if [ -z "$1" ]; then
+    echo "Usage: `basename $0` [tid]"
+    exit 1
+fi
+
+target_mod() {
+    param=$1
+    value=$2
+
+    tgtadm --lld iscsi --mode target --op update \
+	--tid $tid --name $param --value $value
+}
+
+logical_mod() {
+    param=$1
+    value=$2
+
+    # Note that the actuall device is in/at LUN=1, not 0!!
+    tgtadm --lld iscsi --mode logicalunit --op update --tid $tid \
+	--lun 1 --params $param=$value
+}
+
+bind_mod() {
+    value=$1
+
+    tgtadm --lld iscsi --op bind --mode target --tid $tid \
+	--initiator-address $value
+}
+
+unbind_mod() {
+    value=$1
+
+    tgtadm --lld iscsi --op unbind --mode target --tid $tid \
+	--initiator-address $value
+}
+
+# ----------------------------------------------
+
+# Only edit this after this point.
+
+target_mod InitialR2T	No
+target_mod ImmediateData Yes
+
+target_mod MaxRecvDataSegmentLength 262144
+target_mod MaxXmitDataSegmentLength 65536
+
+target_mod MaxBurstLength 131072
+target_mod FirstBurstLength 32768
+target_mod MaxOutstandingR2T 1
+
+target_mod HeaderDigest "CRC32C,None"
+target_mod DataDigest "CRC32C,None"
+
+# By default, 'ALL' have access to the target (see tgtadm(8))
+# So here we remove that and add localhost instead.
+#unbind_mod ALL
+#bind_mod 127.0.0.1
+
+exit 0
Index: pkg-zfs/lib/libzfs/libzfs_changelist.c
===================================================================
--- pkg-zfs.orig/lib/libzfs/libzfs_changelist.c	2016-05-10 22:52:18.375925772 +0000
+++ pkg-zfs/lib/libzfs/libzfs_changelist.c	2016-05-10 22:53:08.755292417 +0000
@@ -72,7 +72,8 @@
 struct prop_changelist {
 	zfs_prop_t		cl_prop;
 	zfs_prop_t		cl_realprop;
-	zfs_prop_t		cl_shareprop;  /* used with sharenfs/sharesmb */
+	/* used with sharenfs/sharesmb/shareiscsi */
+	zfs_prop_t		cl_shareprop;
 	uu_list_pool_t		*cl_pool;
 	uu_list_t		*cl_list;
 	boolean_t		cl_waslegacy;
@@ -86,9 +87,10 @@
 
 /*
  * If the property is 'mountpoint', go through and unmount filesystems as
- * necessary.  We don't do the same for 'sharenfs', because we can just re-share
- * with different options without interrupting service. We do handle 'sharesmb'
- * since there may be old resource names that need to be removed.
+ * necessary.  We don't do the same for 'sharenfs'/'shareiscsi', because we
+ * can just re-share with different options without interrupting service.
+ * We do handle 'sharesmb' since there may be old resource names that need
+ * to be removed.
  */
 int
 changelist_prefix(prop_changelist_t *clp)
@@ -97,7 +99,8 @@
 	int ret = 0;
 
 	if (clp->cl_prop != ZFS_PROP_MOUNTPOINT &&
-	    clp->cl_prop != ZFS_PROP_SHARESMB)
+	    clp->cl_prop != ZFS_PROP_SHARESMB &&
+	    clp->cl_prop != ZFS_PROP_SHAREISCSI)
 		return (0);
 
 	for (cn = uu_list_first(clp->cl_list); cn != NULL;
@@ -134,6 +137,17 @@
 			default:
 				break;
 			}
+		} else if (ZFS_IS_VOLUME(cn->cn_handle) && cn->cn_shared &&
+			    clp->cl_realprop == ZFS_PROP_NAME) {
+			/* If this was a rename, unshare the zvol */
+
+			/*
+			 * XXX: Sometimes (quite often actually), the rename
+			 *      IOCTL that follows hangs (because of this?
+			 *      - works without it, but the old share won't
+			 *  get removed/unshared)...
+			 */
+			(void) zfs_unshare_iscsi(cn->cn_handle, NULL);
 		}
 	}
 
@@ -144,10 +158,11 @@
 }
 
 /*
- * If the property is 'mountpoint' or 'sharenfs', go through and remount and/or
- * reshare the filesystems as necessary.  In changelist_gather() we recorded
- * whether the filesystem was previously shared or mounted.  The action we take
- * depends on the previous state, and whether the value was previously 'legacy'.
+ * If the property is 'mountpoint', 'sharenfs' or 'sharesmb', go through and
+ * remount and/or reshare the filesystems as necessary.  In changelist_gather()
+ * we recorded whether the filesystem was previously shared or mounted.  The
+ * action we take depends on the previous state, and whether the value was
+ * previously 'legacy'.
  * For non-legacy properties, we only remount/reshare the filesystem if it was
  * previously mounted/shared.  Otherwise, we always remount/reshare the
  * filesystem.
@@ -195,6 +210,7 @@
 
 		boolean_t sharenfs;
 		boolean_t sharesmb;
+		boolean_t shareiscsi;
 		boolean_t mounted;
 
 		/*
@@ -211,9 +227,6 @@
 
 		zfs_refresh_properties(cn->cn_handle);
 
-		if (ZFS_IS_VOLUME(cn->cn_handle))
-			continue;
-
 		/*
 		 * Remount if previously mounted or mountpoint was legacy,
 		 * or sharenfs or sharesmb  property is set.
@@ -226,13 +239,16 @@
 		    shareopts, sizeof (shareopts), NULL, NULL, 0,
 		    B_FALSE) == 0) && (strcmp(shareopts, "off") != 0));
 
+		shareiscsi = ((zfs_prop_get(cn->cn_handle, ZFS_PROP_SHAREISCSI,
+		    shareopts, sizeof (shareopts), NULL, NULL, 0,
+		    B_FALSE) == 0) && (strcmp(shareopts, "off") != 0));
+
 		mounted = zfs_is_mounted(cn->cn_handle, NULL);
 
 		if (!mounted && (cn->cn_mounted ||
 		    ((sharenfs || sharesmb || clp->cl_waslegacy) &&
 		    (zfs_prop_get_int(cn->cn_handle,
 		    ZFS_PROP_CANMOUNT) == ZFS_CANMOUNT_ON)))) {
-
 			if (zfs_mount(cn->cn_handle, NULL, 0) != 0)
 				errors++;
 			else
@@ -244,14 +260,10 @@
 		 * if the filesystem is currently shared, so that we can
 		 * adopt any new options.
 		 */
-		if (sharenfs && mounted)
-			errors += zfs_share_nfs(cn->cn_handle);
-		else if (cn->cn_shared || clp->cl_waslegacy)
-			errors += zfs_unshare_nfs(cn->cn_handle, NULL);
-		if (sharesmb && mounted)
-			errors += zfs_share_smb(cn->cn_handle);
+		if (((sharenfs || sharesmb) && mounted) || shareiscsi)
+			errors += zfs_share(cn->cn_handle);
 		else if (cn->cn_shared || clp->cl_waslegacy)
-			errors += zfs_unshare_smb(cn->cn_handle, NULL);
+			errors += zfs_unshare(cn->cn_handle);
 	}
 
 	return (errors ? -1 : 0);
@@ -321,7 +333,8 @@
 	int ret = 0;
 
 	if (clp->cl_prop != ZFS_PROP_SHARENFS &&
-	    clp->cl_prop != ZFS_PROP_SHARESMB)
+	    clp->cl_prop != ZFS_PROP_SHARESMB &&
+	    clp->cl_prop != ZFS_PROP_SHAREISCSI)
 		return (0);
 
 	for (cn = uu_list_first(clp->cl_list); cn != NULL;
@@ -417,7 +430,7 @@
 	}
 
 	/*
-	 * If we are "watching" sharenfs or sharesmb
+	 * If we are "watching" sharenfs, sharesmb or shareiscsi
 	 * then check out the companion property which is tracked
 	 * in cl_shareprop
 	 */
@@ -611,13 +624,15 @@
 
 	if (clp->cl_prop != ZFS_PROP_MOUNTPOINT &&
 	    clp->cl_prop != ZFS_PROP_SHARENFS &&
-	    clp->cl_prop != ZFS_PROP_SHARESMB)
+	    clp->cl_prop != ZFS_PROP_SHARESMB &&
+	    clp->cl_prop != ZFS_PROP_SHAREISCSI)
 		return (clp);
 
 	/*
 	 * If watching SHARENFS or SHARESMB then
 	 * also watch its companion property.
 	 */
+	/* TODO: add SHAREISCSI ? */
 	if (clp->cl_prop == ZFS_PROP_SHARENFS)
 		clp->cl_shareprop = ZFS_PROP_SHARESMB;
 	else if (clp->cl_prop == ZFS_PROP_SHARESMB)
Index: pkg-zfs/lib/libzfs/libzfs_dataset.c
===================================================================
--- pkg-zfs.orig/lib/libzfs/libzfs_dataset.c	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/lib/libzfs/libzfs_dataset.c	2016-05-10 22:53:08.763292317 +0000
@@ -1175,6 +1175,7 @@
 
 		case ZFS_PROP_SHARESMB:
 		case ZFS_PROP_SHARENFS:
+		case ZFS_PROP_SHAREISCSI:
 			/*
 			 * For the mountpoint and sharenfs or sharesmb
 			 * properties, check if it can be set in a
@@ -1201,7 +1202,8 @@
 					    errbuf);
 					goto error;
 				} else if (prop == ZFS_PROP_SHARENFS ||
-				    prop == ZFS_PROP_SHARESMB) {
+					    prop == ZFS_PROP_SHARESMB ||
+					    prop == ZFS_PROP_SHAREISCSI) {
 					zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
 					    "'%s' cannot be set in "
 					    "a non-global zone"), propname);
@@ -1227,12 +1229,15 @@
 			 * property value is valid if it is sharenfs.
 			 */
 			if ((prop == ZFS_PROP_SHARENFS ||
-			    prop == ZFS_PROP_SHARESMB) &&
+			    prop == ZFS_PROP_SHARESMB ||
+			    prop == ZFS_PROP_SHAREISCSI) &&
 			    strcmp(strval, "on") != 0 &&
 			    strcmp(strval, "off") != 0) {
 				zfs_share_proto_t proto;
 
-				if (prop == ZFS_PROP_SHARESMB)
+				if (prop == ZFS_PROP_SHAREISCSI)
+					proto = PROTO_ISCSI;
+				else if (prop == ZFS_PROP_SHARESMB)
 					proto = PROTO_SMB;
 				else
 					proto = PROTO_NFS;
@@ -4059,6 +4064,14 @@
 			(void) changelist_postfix(cl);
 	} else {
 		if (cl != NULL) {
+			/*
+			 * XXX: This 'removes' the old ZVOL name from the
+			 *      list, making changelist_postfix() not
+			 *      removing the old share, which leaves
+			 *      TWO shares - the old and the new!
+			 *
+			 *      But why does it work for NFS and SMB!?
+			 */
 			changelist_rename(cl, zfs_get_name(zhp), target);
 			ret = changelist_postfix(cl);
 		}
Index: pkg-zfs/lib/libzfs/libzfs_mount.c
===================================================================
--- pkg-zfs.orig/lib/libzfs/libzfs_mount.c	2016-05-10 22:52:18.375925772 +0000
+++ pkg-zfs/lib/libzfs/libzfs_mount.c	2016-05-10 22:53:08.767292266 +0000
@@ -45,12 +45,15 @@
  *
  * 	zfs_is_shared_nfs()
  * 	zfs_is_shared_smb()
+ * 	zfs_is_shared_iscsi()
  * 	zfs_share_proto()
  * 	zfs_shareall();
  * 	zfs_unshare_nfs()
  * 	zfs_unshare_smb()
+ * 	zfs_unshare_iscsi()
  * 	zfs_unshareall_nfs()
  *	zfs_unshareall_smb()
+ *	zfs_unshareall_iscsi()
  *	zfs_unshareall()
  *	zfs_unshareall_bypath()
  *
@@ -101,6 +104,8 @@
 proto_table_t proto_table[PROTO_END] = {
 	{ZFS_PROP_SHARENFS, "nfs", EZFS_SHARENFSFAILED, EZFS_UNSHARENFSFAILED},
 	{ZFS_PROP_SHARESMB, "smb", EZFS_SHARESMBFAILED, EZFS_UNSHARESMBFAILED},
+	{ZFS_PROP_SHAREISCSI, "iscsi", EZFS_SHAREISCSIFAILED,
+	    EZFS_UNSHAREISCSIFAILED},
 };
 
 zfs_share_proto_t nfs_only[] = {
@@ -112,9 +117,15 @@
 	PROTO_SMB,
 	PROTO_END
 };
+
+zfs_share_proto_t iscsi_only[] = {
+	PROTO_ISCSI,
+	PROTO_END
+};
 zfs_share_proto_t share_all_proto[] = {
 	PROTO_NFS,
 	PROTO_SMB,
+	PROTO_ISCSI,
 	PROTO_END
 };
 
@@ -134,7 +145,6 @@
 	(void) fseek(hdl->libzfs_sharetab, 0, SEEK_SET);
 
 	while (fgets(buf, sizeof (buf), hdl->libzfs_sharetab) != NULL) {
-
 		/* the mountpoint is the first entry on each line */
 		if ((tab = strchr(buf, '\t')) == NULL)
 			continue;
@@ -153,12 +163,14 @@
 				continue;
 			*tab = '\0';
 			if (strcmp(ptr,
-			    proto_table[proto].p_name) == 0) {
+				    proto_table[proto].p_name) == 0) {
 				switch (proto) {
 				case PROTO_NFS:
 					return (SHARED_NFS);
 				case PROTO_SMB:
 					return (SHARED_SMB);
+				case PROTO_ISCSI:
+					return (SHARED_ISCSI);
 				default:
 					return (0);
 				}
@@ -548,15 +560,21 @@
 	char *mntpt = NULL;
 
 	/* check to see if we need to unmount the filesystem */
-	if (mountpoint != NULL || ((zfs_get_type(zhp) == ZFS_TYPE_FILESYSTEM) &&
-	    libzfs_mnttab_find(hdl, zhp->zfs_name, &entry) == 0)) {
+	if ((mountpoint != NULL ||
+	    ((zfs_get_type(zhp) == ZFS_TYPE_FILESYSTEM) &&
+	    libzfs_mnttab_find(hdl, zhp->zfs_name, &entry) == 0)) ||
+	    zfs_get_type(zhp) == ZFS_TYPE_VOLUME) {
 		/*
 		 * mountpoint may have come from a call to
 		 * getmnt/getmntany if it isn't NULL. If it is NULL,
 		 * we know it comes from libzfs_mnttab_find which can
 		 * then get freed later. We strdup it to play it safe.
 		 */
-		if (mountpoint == NULL)
+		if (ZFS_IS_VOLUME(zhp)) {
+			if (asprintf(&mntpt, "%s/%s/%s", ZVOL_DIR, ZVOL_DRIVER,
+				    zfs_get_name(zhp)) < 0)
+				return (SHARED_NOT_SHARED);
+		} else if (mountpoint == NULL)
 			mntpt = zfs_strdup(hdl, entry.mnt_mountp);
 		else
 			mntpt = zfs_strdup(hdl, mountpoint);
@@ -564,10 +582,22 @@
 		/*
 		 * Unshare and unmount the filesystem
 		 */
-		if (zfs_unshare_proto(zhp, mntpt, share_all_proto) != 0)
-			return (-1);
+		zfs_share_proto_t *curr_proto;
+		for (curr_proto = share_all_proto; *curr_proto != PROTO_END;
+			curr_proto++) {
+			if (is_shared(hdl, mntpt, *curr_proto)) {
+				if (zfs_unshare_proto(zhp, mntpt, curr_proto)
+				    != 0) {
+					break;
+				} else {
+					/* STGT needs a little more time */
+					(void) usleep(500000);
+				}
+			}
+		}
 
-		if (unmount_one(hdl, mntpt, flags) != 0) {
+		if (zfs_get_type(zhp) == ZFS_TYPE_FILESYSTEM &&
+		    unmount_one(hdl, mntpt, flags) != 0) {
 			free(mntpt);
 			(void) zfs_shareall(zhp);
 			return (-1);
@@ -606,9 +636,6 @@
 	zfs_share_type_t rc = 0;
 	zfs_share_proto_t *curr_proto;
 
-	if (ZFS_IS_VOLUME(zhp))
-		return (B_FALSE);
-
 	for (curr_proto = share_all_proto; *curr_proto != PROTO_END;
 	    curr_proto++)
 		rc |= zfs_is_shared_proto(zhp, NULL, *curr_proto);
@@ -619,14 +646,12 @@
 int
 zfs_share(zfs_handle_t *zhp)
 {
-	assert(!ZFS_IS_VOLUME(zhp));
 	return (zfs_share_proto(zhp, share_all_proto));
 }
 
 int
 zfs_unshare(zfs_handle_t *zhp)
 {
-	assert(!ZFS_IS_VOLUME(zhp));
 	return (zfs_unshareall(zhp));
 }
 
@@ -639,7 +664,12 @@
 	char *mountpoint;
 	zfs_share_type_t rc;
 
-	if (!zfs_is_mounted(zhp, &mountpoint))
+	if (ZFS_IS_VOLUME(zhp)) {
+		if (asprintf(&mountpoint, "%s/%s/%s",
+			    ZVOL_DIR, ZVOL_DRIVER,
+			    zfs_get_name(zhp)) < 0)
+			return (SHARED_NOT_SHARED);
+	} else if (!zfs_is_mounted(zhp, &mountpoint))
 		return (SHARED_NOT_SHARED);
 
 	if ((rc = is_shared(zhp->zfs_hdl, mountpoint, proto))) {
@@ -668,6 +698,13 @@
 	    PROTO_SMB) != SHARED_NOT_SHARED);
 }
 
+boolean_t
+zfs_is_shared_iscsi(zfs_handle_t *zhp, char **where)
+{
+	return (zfs_is_shared_proto(zhp, where,
+	    PROTO_ISCSI) != SHARED_NOT_SHARED);
+}
+
 /*
  * zfs_init_libshare(zhandle, service)
  *
@@ -736,8 +773,8 @@
 
 /*
  * Share the given filesystem according to the options in the specified
- * protocol specific properties (sharenfs, sharesmb).  We rely
- * on "libshare" to do the dirty work for us.
+ * protocol specific properties (sharenfs, sharesmb, shareiscsi).  We rely
+ * on "libshare" to the dirty work for us.
  */
 static int
 zfs_share_proto(zfs_handle_t *zhp, zfs_share_proto_t *proto)
@@ -751,7 +788,10 @@
 	zprop_source_t sourcetype;
 	int ret;
 
-	if (!zfs_is_mountable(zhp, mountpoint, sizeof (mountpoint), NULL))
+	if (ZFS_IS_VOLUME(zhp))
+		snprintf(mountpoint, sizeof (mountpoint), "%s/%s/%s",
+			    ZVOL_DIR, ZVOL_DRIVER, zfs_get_name(zhp));
+	else if (!zfs_is_mountable(zhp, mountpoint, sizeof (mountpoint), NULL))
 		return (0);
 
 	for (curr_proto = proto; *curr_proto != PROTO_END; curr_proto++) {
@@ -843,6 +883,12 @@
 }
 
 int
+zfs_share_iscsi(zfs_handle_t *zhp)
+{
+	return (zfs_share_proto(zhp, iscsi_only));
+}
+
+int
 zfs_shareall(zfs_handle_t *zhp)
 {
 	return (zfs_share_proto(zhp, share_all_proto));
@@ -858,6 +904,7 @@
 	sa_share_t share;
 	int err;
 	char *mntpt;
+
 	/*
 	 * Mountpoint could get trashed if libshare calls getmntany
 	 * which it does during API initialization, so strdup the
@@ -905,9 +952,17 @@
 	/* check to see if need to unmount the filesystem */
 	if (mountpoint != NULL)
 		mountpoint = mntpt = zfs_strdup(hdl, mountpoint);
+	else if (ZFS_IS_VOLUME(zhp)) {
+		if (asprintf(&mntpt, "%s/%s/%s", ZVOL_DIR, ZVOL_DRIVER,
+			    zfs_get_name(zhp)) < 0)
+			return (SHARED_NOT_SHARED);
+		mountpoint = mntpt;
+	}
 
-	if (mountpoint != NULL || ((zfs_get_type(zhp) == ZFS_TYPE_FILESYSTEM) &&
-	    libzfs_mnttab_find(hdl, zfs_get_name(zhp), &entry) == 0)) {
+	if ((mountpoint != NULL ||
+	    ((zfs_get_type(zhp) == ZFS_TYPE_FILESYSTEM) &&
+	    libzfs_mnttab_find(hdl, zhp->zfs_name, &entry) == 0)) ||
+	    zfs_get_type(zhp) == ZFS_TYPE_VOLUME) {
 		zfs_share_proto_t *curr_proto;
 
 		if (mountpoint == NULL)
@@ -943,6 +998,12 @@
 	return (zfs_unshare_proto(zhp, mountpoint, smb_only));
 }
 
+int
+zfs_unshare_iscsi(zfs_handle_t *zhp, const char *mountpoint)
+{
+	return (zfs_unshare_proto(zhp, mountpoint, iscsi_only));
+}
+
 /*
  * Same as zfs_unmountall(), but for NFS and SMB unshares.
  */
@@ -975,6 +1036,12 @@
 }
 
 int
+zfs_unshareall_iscsi(zfs_handle_t *zhp)
+{
+	return (zfs_unshareall_proto(zhp, iscsi_only));
+}
+
+int
 zfs_unshareall(zfs_handle_t *zhp)
 {
 	return (zfs_unshareall_proto(zhp, share_all_proto));
Index: pkg-zfs/lib/libzfs/libzfs_util.c
===================================================================
--- pkg-zfs.orig/lib/libzfs/libzfs_util.c	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/lib/libzfs/libzfs_util.c	2016-05-10 22:53:08.787292015 +0000
@@ -168,6 +168,10 @@
 		return (dgettext(TEXT_DOMAIN, "smb remove share failed"));
 	case EZFS_SHARESMBFAILED:
 		return (dgettext(TEXT_DOMAIN, "smb add share failed"));
+	case EZFS_UNSHAREISCSIFAILED:
+		return (dgettext(TEXT_DOMAIN, "iSCSI remove share failed"));
+	case EZFS_SHAREISCSIFAILED:
+		return (dgettext(TEXT_DOMAIN, "iSCSI add share failed"));
 	case EZFS_PERM:
 		return (dgettext(TEXT_DOMAIN, "permission denied"));
 	case EZFS_NOSPC:
Index: pkg-zfs/man/man8/zfs.8
===================================================================
--- pkg-zfs.orig/man/man8/zfs.8	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/man/man8/zfs.8	2016-05-10 22:53:08.791291965 +0000
@@ -1220,6 +1220,348 @@
 .ne 2
 .mk
 .na
+\fB\fBshareiscsi\fR=\fBon\fR | \fBoff\fR\fR | \fIopts\fR\fR
+.ad
+.sp .6
+.RS 4n
+Controls whether a \fBZFS\fR volume is exported as an \fBiSCSI\fR target. The file system is automatically shared and unshared with the zfs share and unshare commands. If the property is set to \fIon\fR, the \fBietadm(8)\fR or \fBtgtadm(8)\fR (depending on iSCSI implementation - see below) command is invokded with default options (see below) to create a iSCSI share. If the property is set to \fIoff\fR, the volume is unshared.
+.sp
+On Linux, the following iSCSI target implementations is supported:
+.RS
+.IP \[bu] 2
+IET
+http://iscsitarget.sourceforge.net
+.IP \[bu] 2
+STGT
+http://stgt.berlios.de
+.IP \[bu] 2
+SCST
+http://scst.sourceforge.net
+.IP \[bu] 2
+LIO
+http://linux-iscsi.org
+.RE
+.sp
+and the following options (indepentent on implementation):
+.RS
+.IP \[bu] 2
+\fBname\fR
+(or it's alias \fBiqn\fR)
+.IP \[bu] 2
+\fBlun\fR
+.IP \[bu] 2
+\fBiomode\fR
+.sp
+.RS
+\fBNOTE\fR: Ignored for \fULIO\fR - no such option in the ConfigFS.
+.RE
+.IP \[bu] 2
+\fBtype\fR
+.IP \[bu] 2
+\fBblocksize\fR
+.sp
+.RS
+\fBNOTE\fR: Ignored for \fUSTGT\fR - no such option in \fBtgtadm\fR.
+.RE
+.IP \[bu] 2
+\fBinitiator\fR
+(or it's alias \fBacl\fR)
+.sp
+.RS
+\fBNOTE\fR: Only availible for \fBLIO\fR, \fBSCST\fR and \fBSTGT\fR.
+.RE
+.IP \[bu] 2
+\fBauthname\fR
+.IP \[bu] 2
+\fBauthpass\fR
+.RE
+.sp
+Discovery of which iSCSI implementation to use is automatic. However, if, for some very weird reason,
+all is installed (technically possible, although not recommended obviously), then the above order
+is used and first match is used.
+
+.sp
+Detailed information about the options:
+.RS
+.sp
+.IP \fBname\fR
+The \fBname\fR option is the full iSCSI Qualified Name (IQN), including identifier, such as:
+.sp
+.in +8
+iqn.2012-11.com.bayour:tank.some.volume
+.in -8
+.sp
+If \fBname\fR is not specified as an option, the module will either fetch the TID (\fBT\fRarget \fBID\fR) from \fB/etc/iscsi_target_id\fR or autogenerate it using the domain name and the current date (YYYY-MM). It will then add the volume name (the 'identifier' in iSCSI speech), replacing the slash characters in the dataset name with dots. If autogenerating the TID, the domainname needs to be set in \fB/etc/domainname\fR (by echo'ing the domain name to the file) or \fB/proc/sys/kernel/domainname\fR (by using sysctl - usually \fB/etc/sysctl.conf\fR) for the driver to work out the iqn correctly.
+.sp
+The content of the \fB/etc/iscsi_target_id\fR can look some thing like this:
+.sp
+.in +8
+iqn.2010-09.org.zfsonlinux
+.in -8
+.sp
+That is: The word 'iqn', a dot, year, a dash and the number of the month, a dot and then the reversed form of the domain for the machine (in this case \fBzfsonlinux.org\fR) and then a newline. The line must start at the first column (no leading spaces etc) and contain only one line. If the \fBname\fR option is used, the \fB/etc/iscsi_target_id\fR and the hosts domain name is ignored.
+.sp
+.IP \fBlun\fR
+The \fBlun\fR is an integer between 0 and 16384 (255 for \fBLIO\fR) and the first \fIlun\fR defined MUST be 0 (the default). For \fBSTGT\fR the default lun is 1, because \fULUN0\fR is the controller and can't have a device ('backing store' in \fBSTGT\fR speach).
+.sp
+.IP \fBiomode\fR
+The possible values for \fBiomode\fR when using \fBSCST\fR is \fIwt\fR (\fBW\fRrite-\fBT\fRhrough - the default), \fIwb\fR (\fBW\fRrite-\fBB\fRack caching) and \fIro\fR (\fBR\fRead-\fBO\fRnly).
+.sp
+\fBNOTE\fR: This is called \fIbstype\fR in \fBSTGT\fR and can be used as an alias for \fIiomode\fR.
+.sp
+\fBWARNING: IOMode=wb could lead to serious data loss from an unexpected system failure (power loss, system crash). Use at your own risk!\fR
+.sp
+For \fBSTGT\fR, the only possible values is: \fBrdwr\fR (the default), \fBaio\fR, \fBmmap\fR, \fBsg\fR and \fBssc\fR.
+.sp
+For \fBLIO\fR, the only possible values is: \fBrw\fR (\fBR\fRead-\fBW\fRrite - the default) and \fBro\fR (for \fBR\fRead-\fBO\fRnly).
+.sp
+This is a global setting for all \fBinitiator\fRs. To override individual access mode per initiator, see the \fBinitiator\fR option below.
+.sp
+.IP \fBtype\fR
+The possible options for \fBtype\fR on Linux is: \fIfileio\fR, \fIblockio\fR or \fInullio\fR. For compability with the *Solaris and *BSD implementations of ZFS, using either \fBtype=disk\fR or \fBtype=tape\fR is accepted, but will both be replaced with the default value \fBtype=blockio\fR.
+.sp
+\fBNOTE:\fR \fIIOMode\fR \fIwb\fR is replaced with \fIwt\fR if using \fBtype=blockio\fR, as it performs no caching.
+.sp
+For \fBSTGT\fR, the following additional values is accepted: \fBssc\fR and \fBpt\fR.
+.sp
+For \fBLIO\fR, the the following additional values is accepted: \fBiblock\fR (alias for \fBblockio\fR). With \fBLIO\fR, \fInullio\fR is an invalid choice. The \fIfileio\fR backstore is using synchronously data transfer and the \fIiblock\fR is using asynchronously data transfers.
+.sp
+.IP \fBblocksize\fR
+The possible values for \fBblocksize\fR is 512, 1024, 2048 or 4096 (the default). If any other value is specified, ZFS will fail with an error \fIcannot be set to invalid options\fR.
+.sp
+\fBWARNING: Once your data is written at a given block size, you cannot change it without risking corruption of your existing data.\fR
+.sp
+For \fBSTGT\fR, this option is ignored, since it isn't possible to specify a blocksize when creating a lun.
+.sp
+.IP \fBinitiator\fR
+This option is \fUonly\fR availible if using the \fBLIO\fR, \fBSCST\fR and \fBSTGT\fR iSCSI implementation.
+.sp
+To enable a target with access control, a mapped lun (for \fBLIO\fR) or security group (for \fBSCST\fR) must be created. For \fBLIO\fR and \fBSCST\fR, this value of this option is the full iSCSI Qualified Name (IQN) of a Initiator that can have access to this target. For \fBSTGT\fR it is the IP address of the initiator.
+.sp
+The format for this option is:
+.sp
+.in +4
+\fB<initiator iqn or ip>\fR[=\fB<access mode>\fR][;.....]
+.sp
+.in -4
+If access mode (\fBro\fR for read-only and \fBrw\fR for read-write) is not set, the value in \fBiomode\fR (if any) is used. Otherwise, \fBrw\fR is used.
+.sp
+\fBExample\fR:
+.in +4
+.sp
+iqn.1993-08.org.debian:01:a59a7552c4a
+.sp
+\fBor\fR:
+.sp
+iqn.1993-08.org.debian:01:a59a7552c4a=ro
+.in -4
+.sp
+If \fBinitiator\fR is specified, access is denied for any other initiator not listed here. For \fBSCST\fR, the regexp chars \fB*\fR and \fB?\fR can be used either alone or in combination with other chars to create a regexp of a initiator.
+.sp
+.IP \fBauthname\fR
+.sp
+If global user does not exist, create it and bind it to the target. When removing target, the user is NOT deleted (it might be in use by another target).
+.sp
+.IP \fBauthpass\fR
+.sp
+Password to use for for authenticating with authname.
+.sp
+For \fBSCST\fR, this needs to be at least 12 bytes long.
+.RE
+.RS
+.sp
+The \fBauthname\fR and \fBauthpass\fR is \fIglobal\fR for all targets. Meaning, that if you specify \fBuser1\fR and \fBpass1\fR for the first target, you can not specify \fBuser1\fR and \fBpass2\fR for the second. The first definition will be used. You will have to specify a different user/password combination for each target you create.
+.sp
+If \fBauthnane\fR and \fBauthpass\fR is set (both needs to be set to enable authentication), but not \fBinitiator\fR, any initiator can connect, but only with specified name and password. Since \fBIET\fR does not support \fBinitiator\fR, any initiator can connect, provided they supply the correct username and password.
+.RE
+.RE
+
+.RS 4n
+.sp
+The module will use the optional script/binary named \fB/sbin/zfs_share_iscsi\fR, if it exists and is executable, after the volume have been shared. The script is intended to do additional, local configuration on the target and lun that can not be done via the \fBshareiscsi\fR property. The only parameter to this script/binary is the TID number
+.sp
+The module will 'execute and forget'. Meaning, ZFS will not care about exit code nor any output it gives. So if the script/binary fails for some reason, it is up to the script to catch any problems - the ZFS module will not intervene.
+.sp
+Example scripts (one for each iSCSI implementation) have been included with the ZoL source code.
+.sp
+Examples on how to use \fBinitiator\fR, \fBauthname\fR and \fBauthpass\fR have been included in \fIExample 25\fR at the end of this document.
+.RE
+
+.sp
+.ne 2
+.mk
+.na
+\fB\fBshareiscsi\fR=\fBon\fR | \fBoff\fR\fR | \fIopts\fR\fR
+.ad
+.sp .6
+.RS 4n
+Controls whether a \fBZFS\fR volume is exported as an \fBiSCSI\fR target. The file system is automatically shared and unshared with the zfs share and unshare commands. If the property is set to \fIon\fR, the \fBietadm(8)\fR or \fBtgtadm(8)\fR (depending on iSCSI implementation - see below) command is invokded with default options (see below) to create a iSCSI share. If the property is set to \fIoff\fR, the volume is unshared.
+.sp
+On Linux, the following iSCSI target implementations is supported:
+.RS
+.IP \[bu] 2
+IET
+http://iscsitarget.sourceforge.net
+.IP \[bu] 2
+STGT
+http://stgt.berlios.de
+.IP \[bu] 2
+SCST
+http://scst.sourceforge.net
+.IP \[bu] 2
+LIO
+http://linux-iscsi.org
+.RE
+.sp
+and the following options (indepentent on implementation):
+.RS
+.IP \[bu] 2
+\fBname\fR
+(or it's alias \fBiqn\fR)
+.IP \[bu] 2
+\fBlun\fR
+.IP \[bu] 2
+\fBiomode\fR
+.sp
+.RS
+\fBNOTE\fR: Ignored for \fULIO\fR - no such option in the ConfigFS.
+.RE
+.IP \[bu] 2
+\fBtype\fR
+.IP \[bu] 2
+\fBblocksize\fR
+.sp
+.RS
+\fBNOTE\fR: Ignored for \fUSTGT\fR - no such option in \fBtgtadm\fR.
+.RE
+.IP \[bu] 2
+\fBinitiator\fR
+(or it's alias \fBacl\fR)
+.sp
+.RS
+\fBNOTE\fR: Only availible for \fBLIO\fR, \fBSCST\fR and \fBSTGT\fR.
+.RE
+.IP \[bu] 2
+\fBauthname\fR
+.IP \[bu] 2
+\fBauthpass\fR
+.RE
+.sp
+Discovery of which iSCSI implementation to use is automatic. However, if, for some very weird reason,
+all is installed (technically possible, although not recommended obviously), then the above order
+is used and first match is used.
+
+.sp
+Detailed information about the options:
+.RS
+.sp
+.IP \fBname\fR
+The \fBname\fR option is the full iSCSI Qualified Name (IQN), including identifier, such as:
+.sp
+.in +8
+iqn.2012-11.com.bayour:tank.some.volume
+.in -8
+.sp
+If \fBname\fR is not specified as an option, the module will either fetch the TID (\fBT\fRarget \fBID\fR) from \fB/etc/iscsi_target_id\fR or autogenerate it using the domain name and the current date (YYYY-MM). It will then add the volume name (the 'identifier' in iSCSI speech), replacing the slash characters in the dataset name with dots. If autogenerating the TID, the domainname needs to be set in \fB/etc/domainname\fR (by echo'ing the domain name to the file) or \fB/proc/sys/kernel/domainname\fR (by using sysctl - usually \fB/etc/sysctl.conf\fR) for the driver to work out the iqn correctly.
+.sp
+The content of the \fB/etc/iscsi_target_id\fR can look some thing like this:
+.sp
+.in +8
+iqn.2010-09.org.zfsonlinux
+.in -8
+.sp
+That is: The word 'iqn', a dot, year, a dash and the number of the month, a dot and then the reversed form of the domain for the machine (in this case \fBzfsonlinux.org\fR) and then a newline. The line must start at the first column (no leading spaces etc) and contain only one line. If the \fBname\fR option is used, the \fB/etc/iscsi_target_id\fR and the hosts domain name is ignored.
+.sp
+.IP \fBlun\fR
+The \fBlun\fR is an integer between 0 and 16384 (255 for \fBLIO\fR) and the first \fIlun\fR defined MUST be 0 (the default). For \fBSTGT\fR the default lun is 1, because \fULUN0\fR is the controller and can't have a device ('backing store' in \fBSTGT\fR speach).
+.sp
+.IP \fBiomode\fR
+The possible values for \fBiomode\fR when using \fBSCST\fR is \fIwt\fR (\fBW\fRrite-\fBT\fRhrough - the default), \fIwb\fR (\fBW\fRrite-\fBB\fRack caching) and \fIro\fR (\fBR\fRead-\fBO\fRnly).
+.sp
+\fBNOTE\fR: This is called \fIbstype\fR in \fBSTGT\fR and can be used as an alias for \fIiomode\fR.
+.sp
+\fBWARNING: IOMode=wb could lead to serious data loss from an unexpected system failure (power loss, system crash). Use at your own risk!\fR
+.sp
+For \fBSTGT\fR, the only possible values is: \fBrdwr\fR (the default), \fBaio\fR, \fBmmap\fR, \fBsg\fR and \fBssc\fR.
+.sp
+For \fBLIO\fR, the only possible values is: \fBrw\fR (\fBR\fRead-\fBW\fRrite - the default) and \fBro\fR (for \fBR\fRead-\fBO\fRnly).
+.sp
+This is a global setting for all \fBinitiator\fRs. To override individual access mode per initiator, see the \fBinitiator\fR option below.
+.sp
+.IP \fBtype\fR
+The possible options for \fBtype\fR on Linux is: \fIfileio\fR, \fIblockio\fR or \fInullio\fR. For compability with the *Solaris and *BSD implementations of ZFS, using either \fBtype=disk\fR or \fBtype=tape\fR is accepted, but will both be replaced with the default value \fBtype=blockio\fR.
+.sp
+\fBNOTE:\fR \fIIOMode\fR \fIwb\fR is replaced with \fIwt\fR if using \fBtype=blockio\fR, as it performs no caching.
+.sp
+For \fBSTGT\fR, the following additional values is accepted: \fBssc\fR and \fBpt\fR.
+.sp
+For \fBLIO\fR, the the following additional values is accepted: \fBiblock\fR (alias for \fBblockio\fR). With \fBLIO\fR, \fInullio\fR is an invalid choice. The \fIfileio\fR backstore is using synchronously data transfer and the \fIiblock\fR is using asynchronously data transfers.
+.sp
+.IP \fBblocksize\fR
+The possible values for \fBblocksize\fR is 512, 1024, 2048 or 4096 (the default). If any other value is specified, ZFS will fail with an error \fIcannot be set to invalid options\fR.
+.sp
+\fBWARNING: Once your data is written at a given block size, you cannot change it without risking corruption of your existing data.\fR
+.sp
+For \fBSTGT\fR, this option is ignored, since it isn't possible to specify a blocksize when creating a lun.
+.sp
+.IP \fBinitiator\fR
+This option is \fUonly\fR availible if using the \fBLIO\fR, \fBSCST\fR and \fBSTGT\fR iSCSI implementation.
+.sp
+To enable a target with access control, a mapped lun (for \fBLIO\fR) or security group (for \fBSCST\fR) must be created. For \fBLIO\fR and \fBSCST\fR, this value of this option is the full iSCSI Qualified Name (IQN) of a Initiator that can have access to this target. For \fBSTGT\fR it is the IP address of the initiator.
+.sp
+The format for this option is:
+.sp
+.in +4
+\fB<initiator iqn or ip>\fR[=\fB<access mode>\fR][;.....]
+.sp
+.in -4
+If access mode (\fBro\fR for read-only and \fBrw\fR for read-write) is not set, the value in \fBiomode\fR (if any) is used. Otherwise, \fBrw\fR is used.
+.sp
+\fBExample\fR:
+.in +4
+.sp
+iqn.1993-08.org.debian:01:a59a7552c4a
+.sp
+\fBor\fR:
+.sp
+iqn.1993-08.org.debian:01:a59a7552c4a=ro
+.in -4
+.sp
+If \fBinitiator\fR is specified, access is denied for any other initiator not listed here. For \fBSCST\fR, the regexp chars \fB*\fR and \fB?\fR can be used either alone or in combination with other chars to create a regexp of a initiator.
+.sp
+.IP \fBauthname\fR
+.sp
+If global user does not exist, create it and bind it to the target. When removing target, the user is NOT deleted (it might be in use by another target).
+.sp
+.IP \fBauthpass\fR
+.sp
+Password to use for for authenticating with authname.
+.sp
+For \fBSCST\fR, this needs to be at least 12 bytes long.
+.RE
+.RS
+.sp
+The \fBauthname\fR and \fBauthpass\fR is \fIglobal\fR for all targets. Meaning, that if you specify \fBuser1\fR and \fBpass1\fR for the first target, you can not specify \fBuser1\fR and \fBpass2\fR for the second. The first definition will be used. You will have to specify a different user/password combination for each target you create.
+.sp
+If \fBauthnane\fR and \fBauthpass\fR is set (both needs to be set to enable authentication), but not \fBinitiator\fR, any initiator can connect, but only with specified name and password. Since \fBIET\fR does not support \fBinitiator\fR, any initiator can connect, provided they supply the correct username and password.
+.RE
+.RE
+
+.RS 4n
+.sp
+The module will use the optional script/binary named \fB/sbin/zfs_share_iscsi\fR, if it exists and is executable, after the volume have been shared. The script is intended to do additional, local configuration on the target and lun that can not be done via the \fBshareiscsi\fR property. The only parameter to this script/binary is the TID number
+.sp
+The module will 'execute and forget'. Meaning, ZFS will not care about exit code nor any output it gives. So if the script/binary fails for some reason, it is up to the script to catch any problems - the ZFS module will not intervene.
+.sp
+Example scripts (one for each iSCSI implementation) have been included with the ZoL source code.
+.sp
+Examples on how to use \fBinitiator\fR, \fBauthname\fR and \fBauthpass\fR have been included in \fIExample 25\fR at the end of this document.
+.RE
+
+.sp
+.ne 2
+.mk
+.na
 \fB\fBsharesmb\fR=\fBon\fR | \fBoff\fR
 .ad
 .sp .6
@@ -3867,6 +4209,152 @@
 .in -2
 .sp
 
+.LP
+\fBExample 25\fR Sharing a volume via iSCSI, limiting access.
+
+.sp
+.LP
+This will create a read-only target, accessible by this one initiator only:
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi=iomode=ro,initiator=iqn.1993-08.org.debian:01:a59a7552c4a rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This will create a read-write target (even though \fBiomode=ro\fR - access mode in the \fBinitiator\fR option will override the value in \fBiomode\fR):
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi=iomode=ro,initiator=iqn.1993-08.org.debian:01:a59a7552c4a=rw rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This will create a read-only target for the first initiator (because no override value), but the second will be able to access it read-write mode. Only these two initiators will have access to the volume. Notice the semi-colon (\fB;\fR) to separate the initiators (because of the semi-colon, the options to \fBshareiscsi\fR needs to be enclosed in double quotes).
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi="iomode=ro,initiator=iqn.1993-08.org.debian:01:a59a7552c4a;iqn.1993-08.org.debian:01:43a7a2e2641f=rw" rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This is the opposite, it will create a read-write target for the first initiator and a read-only target for the second.
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi="iomode=rw,initiator=iqn.1993-08.org.debian:01:a59a7552c4a;iqn.1993-08.org.debian:01:43a7a2e2641f=ro" rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This can also be specified without using \fBiomode\fR.
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi="initiator=iqn.1993-08.org.debian:01:a59a7552c4a=rw;iqn.1993-08.org.debian:01:43a7a2e2641f=ro" rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This will create a target which is accessible to anyone, because of the astrix - any regexp could be used here. It is only accessible in read-only mode. It does give read-write access to the initiator IF it is authenticated with username and password as specified.
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi="initiator=*=ro;iqn.1993-08.org.debian:01:43a7a2e2641f=rw,authname=iscsi-user1,authpass=secret1" rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This will share a read-only target accessible only to the initiator specified and only if authenticated.
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi=initiator=iqn.1993-08.org.debian:01:43a7a2e2641f=ro,authname=iscsi-user1,authpass=verysecret123 rpool/zvol\fR
+.fi
+.in -2
+
+.LP
+\fBExample 25\fR Sharing a volume via iSCSI, limiting access.
+
+.sp
+.LP
+This will create a read-only target, accessible by this one initiator only:
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi=iomode=ro,initiator=iqn.1993-08.org.debian:01:a59a7552c4a rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This will create a read-write target (even though \fBiomode=ro\fR - access mode in the \fBinitiator\fR option will override the value in \fBiomode\fR):
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi=iomode=ro,initiator=iqn.1993-08.org.debian:01:a59a7552c4a=rw rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This will create a read-only target for the first initiator (because no override value), but the second will be able to access it read-write mode. Only these two initiators will have access to the volume. Notice the semi-colon (\fB;\fR) to separate the initiators (because of the semi-colon, the options to \fBshareiscsi\fR needs to be enclosed in double quotes).
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi="iomode=ro,initiator=iqn.1993-08.org.debian:01:a59a7552c4a;iqn.1993-08.org.debian:01:43a7a2e2641f=rw" rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This is the opposite, it will create a read-write target for the first initiator and a read-only target for the second.
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi="iomode=rw,initiator=iqn.1993-08.org.debian:01:a59a7552c4a;iqn.1993-08.org.debian:01:43a7a2e2641f=ro" rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This can also be specified without using \fBiomode\fR.
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi="initiator=iqn.1993-08.org.debian:01:a59a7552c4a=rw;iqn.1993-08.org.debian:01:43a7a2e2641f=ro" rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This will create a target which is accessible to anyone, because of the astrix - any regexp could be used here. It is only accessible in read-only mode. It does give read-write access to the initiator IF it is authenticated with username and password as specified.
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi="initiator=*=ro;iqn.1993-08.org.debian:01:43a7a2e2641f=rw,authname=iscsi-user1,authpass=secret1" rpool/zvol\fR
+.fi
+.in -2
+
+.sp
+.LP
+This will share a read-only target accessible only to the initiator specified and only if authenticated.
+.sp
+.in +2
+.nf
+# \fBzfs set shareiscsi=initiator=iqn.1993-08.org.debian:01:43a7a2e2641f=ro,authname=iscsi-user1,authpass=verysecret123 rpool/zvol\fR
+.fi
+.in -2
+
 .SH "ENVIRONMENT VARIABLES"
 .TP
 .B "ZFS_ABORT
@@ -3910,4 +4398,4 @@
 
 .SH SEE ALSO
 .LP
-\fBchmod\fR(2), \fBfsync\fR(2), \fBgzip\fR(1), \fBmount\fR(8), \fBssh\fR(1), \fBstat\fR(2), \fBwrite\fR(2), \fBzpool\fR(8)
+\fBchmod\fR(2), \fBfsync\fR(2), \fBgzip\fR(1), \fBmount\fR(8), \fBssh\fR(1), \fBstat\fR(2), \fBwrite\fR(2), \fBzpool\fR(8), \fBietd.conf\fR(8), \fBietadm\fR(8), \fBtgtadm\fR()
Index: pkg-zfs/module/zcommon/zfs_prop.c
===================================================================
--- pkg-zfs.orig/module/zcommon/zfs_prop.c	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/module/zcommon/zfs_prop.c	2016-05-10 22:53:08.799291864 +0000
@@ -360,6 +360,9 @@
 	zprop_register_string(ZFS_PROP_SELINUX_ROOTCONTEXT, "rootcontext",
 	    "none", PROP_DEFAULT, ZFS_TYPE_DATASET, "<selinux rootcontext>",
 	    "ROOTCONTEXT");
+	zprop_register_string(ZFS_PROP_SHAREISCSI, "shareiscsi", "off",
+	    PROP_DEFAULT, ZFS_TYPE_VOLUME, "on | off | ietadm/tgtadm(8)"
+	    " options", "SHAREISCSI");
 
 	/* readonly number properties */
 	zprop_register_number(ZFS_PROP_USED, "used", 0, PROP_READONLY,
Index: pkg-zfs/scripts/Makefile.am
===================================================================
--- pkg-zfs.orig/scripts/Makefile.am	2016-05-10 22:52:18.000000000 +0000
+++ pkg-zfs/scripts/Makefile.am	2016-05-10 23:00:21.025858040 +0000
@@ -16,4 +16,5 @@
 	$(top_srcdir)/scripts/zpios-sanity.sh \
 	$(top_srcdir)/scripts/zpios-survey.sh \
 	$(top_srcdir)/scripts/smb.sh \
+	$(top_srcdir)/scripts/iscsi.sh \
 	$(top_srcdir)/scripts/zfs-helpers.sh
Index: pkg-zfs/scripts/iscsi.sh
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ pkg-zfs/scripts/iscsi.sh	2016-05-10 22:53:08.835291412 +0000
@@ -0,0 +1,172 @@
+#!/bin/bash
+
+if [ -d /sys/kernel/scst_tgt ]; then
+    SYSFS=/sys/kernel/scst_tgt
+elif [ -f /proc/net/iet/volume ]; then
+    IETFS=/proc/net/iet/volume
+elif type tgtadm > /dev/null 2>&1; then
+    TGT=`which tgtadm`
+elif type targetcli > /dev/null 2>&1; then
+    LIO=`which targetcli`
+fi
+
+BASETANK=`zpool list -H | sed 's@	.*@@'`
+DATE=`date "+%Y%m%d"`
+
+if [ -z "$1" ]; then
+	echo "Usage: `basename $0` [debug] [iscsi]"
+	exit 1
+fi
+CMDLINE="$*"
+
+set_onoff() {
+	type="$1"
+	dataset="$2"
+	toggle="$3"
+
+	current=`zfs get -H $type -o value $dataset`
+	if [ "$current" != "$toggle" ]; then
+		run "zfs set $type=$toggle $dataset"
+	fi
+}
+
+check_exists() {
+	dataset="$1"
+
+	extra=""
+	[ -n "$2" ] && extra="$2"
+
+	zfs get all "$dataset" > /dev/null 2>&1
+	if [ $? != 0 ]; then
+		run "zfs create $extra $dataset"
+	fi
+}
+
+check_shares() {
+	if [ -n "$SYSFS" ]; then
+	    if type list_scst.pl > /dev/null 2>&1; then
+		run "list_scst.pl"
+	    else
+		run "find $SYSFS/targets/iscsi/iqn.* -maxdepth 0"
+	    fi
+	elif [ -n "$IETFS" ]; then
+	    run "cat /proc/net/iet/volume" | \
+		    egrep '^CMD: |tid:'
+	elif [ -n "$TGT" ]; then
+	    run "tgtadm --lld iscsi --op show --mode target" | \
+		    egrep '^CMD: |Target '
+	elif [ -n "$LIO" ]; then
+	    run "echo '/ ls' | targetcli"
+	fi
+
+	run "cat /etc/dfs/sharetab"
+
+	echo
+
+	if ! echo "$CMDLINE" | egrep -qi "debug"; then
+		sleep 2
+	fi
+}
+
+test_header() {
+	printf "TEST: %s\n" "$*"
+	echo "======================================"
+}
+
+run() {
+	cmd="$*"
+
+	echo "CMD: $cmd"
+
+	if ! echo "$CMDLINE" | egrep -qi "debug"; then
+		$cmd 2>&1 | while IFS= read line; do
+		    echo "     $line"
+		done
+	fi
+}
+
+# =================================================
+
+# -------------------------------------------------
+test_header "Basic setup"
+
+check_exists $BASETANK/tests
+
+str=
+for volnr in {1..5}; do
+	check_exists $BASETANK/tests/iscsi$volnr "-s -V 15G"
+
+	str="$str $BASETANK/tests/iscsi$volnr"
+done
+run "zfs get shareiscsi $str"
+check_shares
+
+# -------------------------------------------------
+echo ; test_header "Autoshare"
+for volnr in {1..5}; do
+	set_onoff shareiscsi $BASETANK/tests/iscsi$volnr on
+	check_shares
+done
+
+# -------------------------------------------------
+echo ; test_header "Unshare single"
+for volnr in {1..5}; do
+	run "zfs unshare $BASETANK/tests/iscsi$volnr"
+	check_shares
+done
+
+# -------------------------------------------------
+echo ; test_header "Share single"
+for volnr in {1..5}; do
+	# NOTE: This is expected to fail if vol already
+	# 	existed (not created by script) and had
+	#	shareiscsi=on set.
+	run "zfs share $BASETANK/tests/iscsi$volnr"
+	check_shares
+done
+
+# -------------------------------------------------
+echo ; test_header "Autounshare"
+for volnr in {1..5}; do
+	set_onoff shareiscsi "$BASETANK/tests/iscsi$volnr" off
+	check_shares
+done
+
+# -------------------------------------------------
+# 1. Start out unshared ('Share single' above)
+# 2. Rename ZVOL
+# 3. Share
+# 4. Rename ZVOL
+echo ; test_header "Rename volume (shared ; unshared)"
+for volnr in {1..5}; do
+	run "zfs rename $BASETANK/tests/iscsi$volnr $BASETANK/tests/new.iscsi$volnr"
+	check_shares
+
+	set_onoff shareiscsi "$BASETANK/tests/new.iscsi$volnr" on
+	check_shares
+
+	run "zfs rename $BASETANK/tests/new.iscsi$volnr $BASETANK/tests/iscsi$volnr"
+	check_shares
+
+	echo
+done
+
+# -------------------------------------------------
+echo ; test_header "Unshare all"
+run "zfs unshare -a"
+check_shares
+
+# -------------------------------------------------
+echo ; test_header "Share all"
+run "zfs share -a"
+check_shares
+
+# -------------------------------------------------
+echo ; test_header "Destroy all"
+run "zfs destroy -r $BASETANK/tests"
+check_shares
+
+# -------------------------------------------------
+echo ; test_header "End"
+run "zfs list"
+check_shares
