commit 7d08880f1f9897e545a8e21d087edc63c03e593f
Author: Turbo Fredriksson <turbo@bayour.com>
Date:   Sat Oct 11 12:40:24 2014 +0200

    Rewrite of nfs.c to keep options per host separated.
    
    Example: Setting sharenfs to
    
      "rw=@192.168.69.8,no_subtree_check,no_root_squash,ro=@192.168.69.45,no_subtree_check,root_squash"
    
    will create the option string
    
      sec=sys,ro,no_subtree_check,no_root_squash,mountpoint,no_subtree_check,no_root_squash,no_subtree_check,root_squash
    
    which is then run on _each host_!. Part of this is "default" options.
    
    Instead, go through the option string, look for hosts and then make
    sure options for each host is kept apart by using a linked list
    (maintained by the ZFS list_* functions). Also, the default options
    should only be added to the list of options if setting sharenfs to
    "on" (and then to the '*' "host").
    
    Closes: #2773

Index: pkg-zfs/lib/libshare/nfs.c
===================================================================
--- pkg-zfs.orig/lib/libshare/nfs.c	2016-03-31 17:18:18.153417963 +0200
+++ pkg-zfs/lib/libshare/nfs.c	2016-03-31 17:18:33.821417586 +0200
@@ -29,12 +29,18 @@
 #include <strings.h>
 #include <fcntl.h>
 #include <sys/wait.h>
+#include <sys/list.h>
 #include <unistd.h>
 #include <libzfs.h>
 #include <libshare.h>
 #include "libshare_impl.h"
 
+#if !defined(offsetof)
+#define	offsetof(s, m)  ((size_t)(&(((s *)0)->m)))
+#endif
+
 static boolean_t nfs_available(void);
+static int nfs_enable_share_one(const char *, const char *, char *);
 
 static sa_fstype_t *nfs_fstype;
 
@@ -44,8 +50,23 @@
  */
 static int nfs_exportfs_temp_fd = -1;
 
+typedef int (*nfs_shareopt_callback_t)(const char *opt, const char *value,
+    void *cookie);
+
+/* List of hosts and their options */
+/* NOTE: share path is stored elsewhere */
+typedef struct nfs_share_list_s {
+	char	host[255];
+	char	opts[255];
+
+	list_node_t next;
+} nfs_share_list_t;
+
+/* Global list of shares */
+list_t all_nfs_shares_list;
+
 typedef int (*nfs_host_callback_t)(const char *sharepath, const char *host,
-    const char *security, const char *access, void *cookie);
+	const char *security, const char *access, void *cookie);
 
 typedef struct nfs_host_cookie_s {
 	nfs_host_callback_t callback;
@@ -54,6 +75,23 @@
 	const char *security;
 } nfs_host_cookie_t;
 
+static int
+find_option(char *opt, const char *needle)
+{
+	char *token, *dup;
+
+	dup = strdup(opt);
+	token = strtok(dup, ",");
+	while (token != NULL) {
+		if (strncmp(token, needle, strlen(needle)) == 0)
+			return (1);
+
+		token = strtok(NULL, ",");
+	}
+
+	return (0);
+}
+
 /*
  * Helper function for foreach_nfs_host. This function checks whether the
  * current share option is a host specification and invokes a callback
@@ -149,13 +187,11 @@
 		 * to skip the @ in this case
 		 */
 		*plinux_hostspec = strdup(solaris_hostspec + 1);
-	} else {
+	} else
 		*plinux_hostspec = strdup(solaris_hostspec);
-	}
 
-	if (*plinux_hostspec == NULL) {
+	if (*plinux_hostspec == NULL)
 		return (SA_NO_MEMORY);
-	}
 
 	return (SA_OK);
 }
@@ -164,45 +200,23 @@
  * Used internally by nfs_enable_share to enable sharing for a single host.
  */
 static int
-nfs_enable_share_one(const char *sharepath, const char *host,
-    const char *security, const char *access, void *pcookie)
+nfs_enable_share_one(const char *sharepath, const char *host, char *opts)
 {
 	int rc;
-	char *linuxhost, *hostpath, *opts;
-	const char *linux_opts = (const char *)pcookie;
+	char *hostpath;
 	char *argv[6];
 
-	/* exportfs -i -o sec=XX,rX,<opts> <host>:<sharepath> */
+	/* exportfs -i -o sec=XX,<opts> <host>:<sharepath> */
 
-	rc = get_linux_hostspec(host, &linuxhost);
-
-	if (rc < 0)
-		exit(1);
-
-	hostpath = malloc(strlen(linuxhost) + 1 + strlen(sharepath) + 1);
-
-	if (hostpath == NULL) {
-		free(linuxhost);
-
-		exit(1);
-	}
-
-	sprintf(hostpath, "%s:%s", linuxhost, sharepath);
-
-	free(linuxhost);
-
-	if (linux_opts == NULL)
-		linux_opts = "";
-
-	opts = malloc(4 + strlen(security) + 4 + strlen(linux_opts) + 1);
-
-	if (opts == NULL)
-		exit(1);
-
-	sprintf(opts, "sec=%s,%s,%s", security, access, linux_opts);
+	hostpath = malloc(strlen(host) + 1 +
+	    strlen(sharepath) + 1);
+	if (hostpath == NULL)
+		return (SA_NO_MEMORY);
+	sprintf(hostpath, "%s:%s", host, sharepath);
 
 #ifdef DEBUG
-	fprintf(stderr, "sharing %s with opts %s\n", hostpath, opts);
+	fprintf(stderr, "sharing %s with opts %s\n",
+		hostpath, (opts ? opts : "NULL"));
 #endif
 
 	argv[0] = "/usr/sbin/exportfs";
@@ -212,10 +226,17 @@
 	argv[4] = hostpath;
 	argv[5] = NULL;
 
+#if DEBUG >= 2
+	int i;
+	fprintf(stderr, "CMD: ");
+	for (i = 0; i < 5; i++)
+		fprintf(stderr, "%s ", argv[i]);
+	fprintf(stderr, "\n");
+#endif
+
 	rc = libzfs_run_process(argv[0], argv, 0);
 
 	free(hostpath);
-	free(opts);
 
 	if (rc < 0)
 		return (SA_SYSTEM_ERR);
@@ -232,12 +253,16 @@
 	size_t len = 0;
 	char *new_linux_opts;
 
-	if (*plinux_opts != NULL)
+	if (*plinux_opts != NULL) {
 		len = strlen(*plinux_opts);
 
+		/* Skip value that already exist */
+		if (find_option(*plinux_opts, key))
+			return (SA_OK);
+	}
+
 	new_linux_opts = realloc(*plinux_opts, len + 1 + strlen(key) +
 	    (value ? 1 + strlen(value) : 0) + 1);
-
 	if (new_linux_opts == NULL)
 		return (SA_NO_MEMORY);
 
@@ -258,19 +283,104 @@
 	return (SA_OK);
 }
 
+static int
+update_host_list(void *cookie)
+{
+	char **plinux_opts = (char **)cookie;
+	nfs_share_list_t *cur_share, *new_share;
+
+	/* Get the last entry in the list. */
+	cur_share = list_tail(&all_nfs_shares_list);
+	if (cur_share == NULL)
+		return (SA_OK);
+
+	/* Create a new object list */
+	new_share = (nfs_share_list_t *)
+		malloc(sizeof (nfs_share_list_t));
+	if (new_share == NULL)
+		return (SA_NO_MEMORY);
+	list_link_init(&new_share->next);
+
+	/* If the current list is empty, the new list is 'world'. */
+	if (cur_share == NULL)
+		strcpy(new_share->host, "*");
+	else
+		strcpy(new_share->host, cur_share->host);
+	sprintf(new_share->opts, "%s", *plinux_opts);
+
+	/* Replace the old head with this new object */
+	if (cur_share->host != NULL)
+		list_link_replace(&cur_share->next, &new_share->next);
+	else
+		list_insert_tail(&all_nfs_shares_list, new_share);
+
+	return (SA_OK);
+}
+
 /*
  * Validates and converts a single Solaris share option to its Linux
- * equivalent.
+ * equivalent, verifies that the option is valid and then stores it
+ * in "cookie"..
  */
 static int
 get_linux_shareopts_cb(const char *key, const char *value, void *cookie)
 {
 	char **plinux_opts = (char **)cookie;
+	nfs_share_list_t *opts = NULL;
 
-	/* host-specific options, these are taken care of elsewhere */
-	if (strcmp(key, "ro") == 0 || strcmp(key, "rw") == 0 ||
-	    strcmp(key, "sec") == 0)
-		return (SA_OK);
+// TODO: Make sure that a 'sec=yyy' (or any other option) BEFORE a/any
+//       'rw[=@xxx]' or 'ro[=@xxx]' works.
+	if (strcmp(key, "ro") == 0 || strcmp(key, "rw") == 0) {
+		opts = (nfs_share_list_t *)
+			malloc(sizeof (nfs_share_list_t));
+		if (opts == NULL)
+			return (SA_NO_MEMORY);
+
+		list_link_init(&opts->next);
+
+		if (*plinux_opts != NULL) {
+			/*
+			 * We're in a new host list, so update the
+			 * previous host definition
+			 */
+			update_host_list(cookie);
+
+			/*
+			 * Zero the current list of options
+			 * so that the next host definition
+			 * starts with an empty option list
+			 */
+			*plinux_opts = NULL;
+		}
+
+		/* Start a new host opts definition */
+		if (value && value[0] == '@') {
+			int rc;
+			char *host;
+
+			/*
+			 * Extract the host or network address from the
+			 * 'rw=@...' value.
+			 */
+			rc = get_linux_hostspec(value, &host);
+			if (rc < 0)
+				return (rc);
+
+			strncpy(opts->host, host, sizeof (opts->host));
+			opts->opts[0] = '\0';
+
+			/*
+			 * Make sure we don't add the '@...' to the options
+			 * list by setting the value to NULL after we're
+			 * done with it.
+			 */
+			value = NULL;
+		} else {
+			strcpy(opts->host, "*");
+			opts->opts[0] = '\0';
+		}
+		list_insert_tail(&all_nfs_shares_list, opts);
+	}
 
 	if (strcmp(key, "anon") == 0)
 		key = "anonuid";
@@ -283,24 +393,37 @@
 	if (strcmp(key, "nosub") == 0)
 		key = "subtree_check";
 
-	if (strcmp(key, "insecure") != 0 && strcmp(key, "secure") != 0 &&
-	    strcmp(key, "async") != 0 && strcmp(key, "sync") != 0 &&
-	    strcmp(key, "no_wdelay") != 0 && strcmp(key, "wdelay") != 0 &&
-	    strcmp(key, "nohide") != 0 && strcmp(key, "hide") != 0 &&
+	if (strcmp(key, "rw") != 0 &&
+	    strcmp(key, "ro") != 0 &&
+	    strcmp(key, "sec") != 0 &&
+	    strcmp(key, "insecure") != 0 &&
+	    strcmp(key, "secure") != 0 &&
+	    strcmp(key, "async") != 0 &&
+	    strcmp(key, "sync") != 0 &&
+	    strcmp(key, "no_wdelay") != 0 &&
+	    strcmp(key, "wdelay") != 0 &&
+	    strcmp(key, "nohide") != 0 &&
+	    strcmp(key, "hide") != 0 &&
 	    strcmp(key, "crossmnt") != 0 &&
 	    strcmp(key, "no_subtree_check") != 0 &&
 	    strcmp(key, "subtree_check") != 0 &&
 	    strcmp(key, "insecure_locks") != 0 &&
 	    strcmp(key, "secure_locks") != 0 &&
-	    strcmp(key, "no_auth_nlm") != 0 && strcmp(key, "auth_nlm") != 0 &&
-	    strcmp(key, "no_acl") != 0 && strcmp(key, "mountpoint") != 0 &&
-	    strcmp(key, "mp") != 0 && strcmp(key, "fsuid") != 0 &&
-	    strcmp(key, "refer") != 0 && strcmp(key, "replicas") != 0 &&
+	    strcmp(key, "no_auth_nlm") != 0 &&
+	    strcmp(key, "auth_nlm") != 0 &&
+	    strcmp(key, "no_acl") != 0 &&
+	    strcmp(key, "mountpoint") != 0 &&
+	    strcmp(key, "mp") != 0 &&
+	    strcmp(key, "fsuid") != 0 &&
+	    strcmp(key, "refer") != 0 &&
+	    strcmp(key, "replicas") != 0 &&
 	    strcmp(key, "root_squash") != 0 &&
 	    strcmp(key, "no_root_squash") != 0 &&
 	    strcmp(key, "all_squash") != 0 &&
-	    strcmp(key, "no_all_squash") != 0 && strcmp(key, "fsid") != 0 &&
-	    strcmp(key, "anonuid") != 0 && strcmp(key, "anongid") != 0) {
+	    strcmp(key, "no_all_squash") != 0 &&
+	    strcmp(key, "fsid") != 0 &&
+	    strcmp(key, "anonuid") != 0 &&
+	    strcmp(key, "anongid") != 0) {
 		return (SA_SYNTAX_ERR);
 	}
 
@@ -320,20 +443,35 @@
 
 	assert(plinux_opts != NULL);
 
-	*plinux_opts = NULL;
+	/* Create global list of share host(s) and options */
+	list_create(&all_nfs_shares_list, sizeof (nfs_share_list_t),
+	    offsetof(nfs_share_list_t, next));
 
-	/* default options for Solaris shares */
-	(void) add_linux_shareopt(plinux_opts, "no_subtree_check", NULL);
-	(void) add_linux_shareopt(plinux_opts, "no_root_squash", NULL);
-	(void) add_linux_shareopt(plinux_opts, "mountpoint", NULL);
+	if (strncmp(shareopts, "rw\0", 3) == 0) {
+		/*
+		 * 'sharenfs=on' => use default options for Solaris shares.
+		 * The 'on' part is changed in nfs_update_shareopts() to 'rw'.
+		 */
+		(void) add_linux_shareopt(plinux_opts, "no_subtree_check",
+		    NULL);
+		(void) add_linux_shareopt(plinux_opts, "no_root_squash", NULL);
+		(void) add_linux_shareopt(plinux_opts, "mountpoint", NULL);
+// TODO: Make sure a 'sharenfs=zzz' WITHOUT a 'rw[=@xxx]' or 'ro[=@xxx]' works
+//	} else if(strcmp(shareopts, "ro\0") != 0) {
+//		/* 'else' only: Doesn't work if there's a 'ro[=@xxx]' somewhere. */
+//		/* 'else if(strcmp(shareopts, "ro\0") == 0)': Doesn't work if there's ONLY a 'ro'. */
+//fprintf(stderr, "  + adding 'rw'\n"); // DEBUG
+//		strcat((char *)shareopts, ",rw");
+	}
 
 	rc = foreach_shareopt(shareopts, get_linux_shareopts_cb, plinux_opts);
-
 	if (rc != SA_OK) {
 		free(*plinux_opts);
 		*plinux_opts = NULL;
 	}
 
+	update_host_list(plinux_opts);
+
 	return (rc);
 }
 
@@ -343,24 +481,30 @@
 static int
 nfs_enable_share(sa_share_impl_t impl_share)
 {
+	int rc = SA_OK;
 	char *shareopts, *linux_opts;
-	int rc;
+	nfs_share_list_t *share;
 
-	if (!nfs_available()) {
+	if (!nfs_available())
 		return (SA_SYSTEM_ERR);
-	}
 
 	shareopts = FSINFO(impl_share, nfs_fstype)->shareopts;
-
 	if (shareopts == NULL)
 		return (SA_OK);
 
-	rc = get_linux_shareopts(shareopts, &linux_opts);
+	linux_opts = calloc(sizeof (nfs_share_list_t), 1);
 
+	rc = get_linux_shareopts(shareopts, &linux_opts);
 	if (rc != SA_OK)
 		return (rc);
 
-	rc = foreach_nfs_host(impl_share, nfs_enable_share_one, linux_opts);
+	for (share = list_head(&all_nfs_shares_list);
+	    share != NULL;
+	    share = list_next(&all_nfs_shares_list, share)) {
+
+		rc = nfs_enable_share_one(impl_share->sharepath,
+		    share->host, share->opts);
+	}
 
 	free(linux_opts);
 
@@ -371,28 +515,18 @@
  * Used internally by nfs_disable_share to disable sharing for a single host.
  */
 static int
-nfs_disable_share_one(const char *sharepath, const char *host,
-    const char *security, const char *access, void *cookie)
+nfs_disable_share_one(const char *sharepath, const char *host, char *opts)
 {
 	int rc;
-	char *linuxhost, *hostpath;
+	char *hostpath;
 	char *argv[4];
 
-	rc = get_linux_hostspec(host, &linuxhost);
-
-	if (rc < 0)
-		exit(1);
-
-	hostpath = malloc(strlen(linuxhost) + 1 + strlen(sharepath) + 1);
-
-	if (hostpath == NULL) {
-		free(linuxhost);
-		exit(1);
-	}
+	/* exportfs -u <host>:<sharepath> */
 
-	sprintf(hostpath, "%s:%s", linuxhost, sharepath);
-
-	free(linuxhost);
+	hostpath = malloc(strlen(host) + 1 + strlen(sharepath) + 1);
+	if (hostpath == NULL)
+		return (SA_NO_MEMORY);
+	sprintf(hostpath, "%s:%s", host, sharepath);
 
 #ifdef DEBUG
 	fprintf(stderr, "unsharing %s\n", hostpath);
@@ -403,6 +537,14 @@
 	argv[2] = hostpath;
 	argv[3] = NULL;
 
+#if DEBUG >= 2
+	int i;
+	fprintf(stderr, "CMD: ");
+	for (i = 0; i < 3; i++)
+		fprintf(stderr, "%s ", argv[i]);
+	fprintf(stderr, "\n");
+#endif
+
 	rc = libzfs_run_process(argv[0], argv, 0);
 
 	free(hostpath);
@@ -419,6 +561,14 @@
 static int
 nfs_disable_share(sa_share_impl_t impl_share)
 {
+	int rc = SA_OK;
+	char *shareopts, *linux_opts;
+	nfs_share_list_t *share;
+
+#ifdef DEBUG
+	fprintf(stderr, "nfs_disable_share: %s\n", impl_share->sharepath);
+#endif
+
 	if (!nfs_available()) {
 		/*
 		 * The share can't possibly be active, so nothing
@@ -427,7 +577,27 @@
 		return (SA_OK);
 	}
 
-	return (foreach_nfs_host(impl_share, nfs_disable_share_one, NULL));
+	shareopts = FSINFO(impl_share, nfs_fstype)->shareopts;
+	if (shareopts == NULL)
+		return (SA_OK);
+
+	linux_opts = calloc(sizeof (nfs_share_list_t), 1);
+
+	rc = get_linux_shareopts(shareopts, &linux_opts);
+	if (rc != SA_OK)
+		return (rc);
+
+	for (share = list_head(&all_nfs_shares_list);
+	    share != NULL;
+	    share = list_next(&all_nfs_shares_list, share)) {
+
+		rc = nfs_disable_share_one(impl_share->sharepath,
+		    share->host, NULL);
+	}
+
+	free(linux_opts);
+
+	return (rc);
 }
 
 /*
@@ -439,6 +609,8 @@
 	char *linux_opts;
 	int rc;
 
+	linux_opts = calloc(sizeof (nfs_share_list_t), 1);
+
 	rc = get_linux_shareopts(shareopts, &linux_opts);
 
 	if (rc != SA_OK)
@@ -601,7 +773,6 @@
 		close(nfs_exportfs_temp_fd);
 
 	nfs_exportfs_temp_fd = mkstemp(nfs_exportfs_tempfile);
-
 	if (nfs_exportfs_temp_fd < 0)
 		return (SA_SYSTEM_ERR);
 
@@ -643,12 +814,10 @@
 		exit(1);
 
 	rc = execlp("/usr/sbin/exportfs", "exportfs", "-v", NULL);
-
-	if (rc < 0) {
+	if (rc < 0)
 		exit(1);
-	}
-
-	exit(0);
+	else
+		exit(0);
 }
 
 /*
